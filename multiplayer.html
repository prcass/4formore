<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>4forMore V5.1.19 - Multiplayer</title>

    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.7.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.0/firebase-database-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.0/firebase-auth-compat.js"></script>

    <!-- Load external token dataset with cache buster -->
    <script src="v4_token_datasets.js?v=7"></script>

    <!-- Firebase configuration and managers -->
    <script src="firebase-config.js"></script>
    <script src="game-mode-manager.js"></script>
    <script src="room-manager.js"></script>
    <script src="qa-tests.js"></script>
    <script src="full-game-test.js"></script>
    <style>
        /* ===== BASE STYLES ===== */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
            touch-action: manipulation;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        /* ===== SCREEN MANAGEMENT ===== */
        .screen {
            display: none;
        }

        .screen.active {
            display: block;
        }

        /* ===== HEADER ===== */
        .header {
            background: white;
            border-radius: 20px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
        }

        .header h1 {
            color: #764ba2;
            font-size: 28px;
            margin-bottom: 5px;
        }

        .header .subtitle {
            color: #666;
            font-size: 14px;
        }

        /* ===== BUTTONS ===== */
        .btn {
            padding: 15px 30px;
            border: none;
            border-radius: 12px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            touch-action: manipulation;
        }

        .btn:active {
            transform: scale(0.95);
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
        }

        .btn-primary:disabled {
            background: #ccc;
            cursor: not-allowed;
            opacity: 0.6;
        }

        .btn-secondary {
            background: #f0f0f0;
            color: #333;
        }

        .btn-success {
            background: #28a745;
            color: white;
        }

        .btn-danger {
            background: #dc3545;
            color: white;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* ===== SETUP SCREEN ===== */
        .setup-content {
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            max-width: 600px;
            margin: 0 auto;
        }

        .form-group {
            margin-bottom: 25px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: #764ba2;
        }

        .form-group input,
        .form-group select {
            width: 100%;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 16px;
        }

        .form-group input:focus,
        .form-group select:focus {
            outline: none;
            border-color: #764ba2;
        }

        .player-inputs {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .player-inputs input {
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 16px;
        }

        /* ===== GAME SCREEN ===== */
        .game-layout {
            display: grid;
            grid-template-columns: 250px 1fr;
            gap: 20px;
        }

        @media (max-width: 768px) {
            .game-layout {
                grid-template-columns: 1fr;
            }
        }

        .panel {
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.1);
        }

        .panel h2 {
            color: #764ba2;
            margin-bottom: 15px;
            font-size: 18px;
            border-bottom: 2px solid #f0f0f0;
            padding-bottom: 10px;
        }

        /* ===== PLAYER INFO PANEL ===== */
        .player-info {
            padding: 12px;
            margin-bottom: 10px;
            background: #f8f8f8;
            border-radius: 10px;
            border: 2px solid transparent;
        }

        .player-info.current-player {
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.1), rgba(118, 75, 162, 0.1));
            border-color: #764ba2;
        }

        .player-info .player-name {
            font-weight: bold;
            font-size: 16px;
            margin-bottom: 5px;
        }

        .player-info .player-score {
            font-size: 24px;
            color: #764ba2;
            font-weight: bold;
        }

        .player-info .player-stats {
            font-size: 12px;
            color: #666;
            margin-top: 5px;
        }

        .first-guesser-marker {
            display: inline-block;
            background: gold;
            color: #333;
            padding: 2px 8px;
            border-radius: 5px;
            font-size: 11px;
            font-weight: bold;
            margin-left: 5px;
        }

        .last-standing-marker {
            display: inline-block;
            font-size: 16px;
            margin-left: 5px;
            animation: pulse 1s ease-in-out infinite;
        }

        /* ===== CHALLENGE INFO ===== */
        .challenge-info {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 20px;
            text-align: center;
        }

        .challenge-info h3 {
            font-size: 24px;
            margin-bottom: 10px;
        }

        .challenge-info .stat-name {
            font-size: 18px;
            opacity: 0.9;
        }

        /* ===== TOKEN DISPLAY ===== */
        .token {
            background: white;
            border-radius: 12px;
            padding: 15px;
            box-shadow: 0 3px 10px rgba(0,0,0,0.1);
            cursor: pointer;
            transition: all 0.2s;
            border: 3px solid transparent;
        }

        .token:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        .token.selected {
            border-color: #764ba2;
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.1), rgba(118, 75, 162, 0.1));
        }

        .token .token-name {
            font-weight: bold;
            font-size: 16px;
            margin-bottom: 5px;
            color: #333;
        }

        .token .token-value {
            font-size: 20px;
            color: #764ba2;
            font-weight: bold;
        }

        .token .token-tags {
            display: flex;
            gap: 5px;
            margin-top: 8px;
        }

        .token-tag {
            background: #f0f0f0;
            padding: 3px 8px;
            border-radius: 5px;
            font-size: 11px;
            font-weight: bold;
            color: #666;
        }

        /* Hide token data when in hidden mode */
        body.hide-data .token-value {
            display: none;
        }

        /* ===== CENTER TOKEN ===== */
        .center-token-area {
            text-align: center;
            margin-bottom: 30px;
        }

        .center-token-area h3 {
            margin-bottom: 15px;
            color: #764ba2;
        }

        .center-token {
            display: inline-block;
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.15);
            border: 4px solid #764ba2;
            min-width: 250px;
        }

        .center-token .token-name {
            font-size: 20px;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .center-token .token-value {
            font-size: 32px;
            color: #764ba2;
            font-weight: bold;
        }

        /* ===== DRAFT POOL ===== */
        .draft-pool {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        /* ===== ACTION BUTTONS ===== */
        .action-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 30px;
        }

        .action-buttons .btn {
            flex: 1;
            max-width: 200px;
        }

        /* ===== LOCKED OUT STATE ===== */
        .locked-out-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            pointer-events: none;
        }

        .locked-out-overlay.active {
            display: flex;
        }

        .locked-out-message {
            background: white;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            max-width: 400px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
        }

        .locked-out-message h2 {
            color: #f44336;
            margin: 0 0 15px 0;
            font-size: 28px;
        }

        .locked-out-message p {
            color: #666;
            margin: 0;
            font-size: 16px;
            line-height: 1.5;
        }

        /* Grey out game area when locked */
        .screen.locked-out .draft-pool,
        .screen.locked-out .guess-area,
        .screen.locked-out .action-buttons {
            opacity: 0.3;
            pointer-events: none;
        }

        /* ===== GUESS BUTTONS ===== */
        .guess-area {
            display: none;
            text-align: center;
            margin: 30px 0;
            padding: 30px;
            background: #f8f8f8;
            border-radius: 15px;
        }

        .guess-area.active {
            display: block;
        }

        .guess-prompt {
            font-size: 20px;
            margin-bottom: 20px;
            font-weight: bold;
        }

        .guess-buttons {
            display: flex;
            gap: 20px;
            justify-content: center;
        }

        .guess-buttons .btn {
            font-size: 24px;
            padding: 20px 50px;
        }

        /* ===== MODALS ===== */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.7);
            z-index: 1000;
            padding: 20px;
        }

        .modal.active {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            background: white;
            border-radius: 20px;
            padding: 30px;
            max-width: 600px;
            width: 100%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal-content h2 {
            color: #764ba2;
            margin-bottom: 20px;
        }

        /* ===== ANIMATIONS ===== */
        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-10px); }
            75% { transform: translateX(10px); }
        }

        @keyframes correctFlash {
            0% { background: white; transform: scale(1); }
            50% { background: #28a745; transform: scale(1.1); }
            100% { background: white; transform: scale(1); }
        }

        @keyframes wrongFlash {
            0% { background: white; transform: scale(1); }
            25% { background: #dc3545; transform: scale(0.95); }
            50% { background: white; transform: scale(1); }
            75% { background: #dc3545; transform: scale(0.95); }
            100% { background: white; transform: scale(1); }
        }

        @keyframes pointsFloat {
            0% {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
            100% {
                opacity: 0;
                transform: translateY(-50px) scale(1.5);
            }
        }

        @keyframes slideDown {
            from {
                transform: translateY(-100%);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        @keyframes slideUp {
            from {
                transform: translateY(0);
                opacity: 1;
            }
            to {
                transform: translateY(-100%);
                opacity: 0;
            }
        }

        @keyframes opponentHighlight {
            0% {
                box-shadow: 0 0 0 0 rgba(79, 172, 254, 0.7);
                transform: scale(1);
            }
            50% {
                box-shadow: 0 0 20px 10px rgba(79, 172, 254, 0.3);
                transform: scale(1.05);
            }
            100% {
                box-shadow: 0 0 0 0 rgba(79, 172, 254, 0);
                transform: scale(1);
            }
        }

        .opponent-action-highlight {
            animation: opponentHighlight 1s ease-in-out 2;
            border: 3px solid #4facfe !important;
        }

        @keyframes celebrate {
            0%, 100% { transform: rotate(0deg) scale(1); }
            25% { transform: rotate(-10deg) scale(1.1); }
            75% { transform: rotate(10deg) scale(1.1); }
        }

        @keyframes tokenSlide {
            0% {
                opacity: 1;
                transform: translateX(0);
            }
            100% {
                opacity: 0;
                transform: translateX(100px);
            }
        }

        .animate-slide-in {
            animation: slideIn 0.3s ease-out;
        }

        .animate-pulse {
            animation: pulse 0.5s ease-in-out;
        }

        .animate-shake {
            animation: shake 0.5s ease-in-out;
        }

        .animate-correct-flash {
            animation: correctFlash 0.6s ease-in-out;
        }

        .animate-wrong-flash {
            animation: wrongFlash 0.8s ease-in-out;
        }

        .animate-celebrate {
            animation: celebrate 0.8s ease-in-out;
        }

        .points-float {
            position: absolute;
            font-size: 32px;
            font-weight: bold;
            color: #28a745;
            animation: pointsFloat 1s ease-out forwards;
            pointer-events: none;
            z-index: 1000;
        }

        /* ===== NOTIFICATIONS ===== */
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: white;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.2);
            z-index: 2000;
            animation: slideIn 0.3s ease-out;
            max-width: 300px;
        }

        .notification.success {
            border-left: 5px solid #28a745;
        }

        .notification.error {
            border-left: 5px solid #dc3545;
        }

        .notification.info {
            border-left: 5px solid #17a2b8;
        }

        /* ===== MOBILE OPTIMIZATIONS ===== */
        @media (max-width: 375px) {
            .container {
                padding: 10px;
            }

            .header h1 {
                font-size: 24px;
            }

            .btn {
                padding: 12px 20px;
                font-size: 14px;
            }

            .draft-pool {
                grid-template-columns: 1fr;
            }

            .guess-buttons {
                flex-direction: column;
            }

            .guess-buttons .btn {
                width: 100%;
            }
        }

        /* V5.0: Bonus Card Styles */
        .bonus-card-pool {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin-top: 10px;
        }

        .bonus-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .bonus-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(0,0,0,0.3);
        }

        .bonus-card .card-header {
            font-weight: bold;
            font-size: 1.1em;
            margin-bottom: 8px;
        }

        .bonus-card .card-description {
            font-size: 0.85em;
            opacity: 0.9;
            margin-bottom: 8px;
            line-height: 1.4;
        }

        .bonus-card .card-type {
            font-size: 0.75em;
            background: rgba(255,255,255,0.2);
            padding: 3px 8px;
            border-radius: 10px;
            display: inline-block;
            text-transform: uppercase;
        }

        .bonus-card-option {
            cursor: pointer;
            user-select: none;
        }

        @media (max-width: 600px) {
            .bonus-card-pool {
                grid-template-columns: 1fr;
            }

            .bonus-card {
                padding: 12px;
            }

            .bonus-card .card-header {
                font-size: 1em;
            }
        }
    </style>
</head>
<body>
    <!-- Mode Indicator -->
    <div id="modeIndicator" style="position: fixed; top: 10px; right: 10px;
                                    padding: 8px 15px; border-radius: 20px;
                                    background: #667eea; color: white;
                                    font-size: 12px; font-weight: bold;
                                    z-index: 1000; display: none;">
        <span id="modeText">🏠 Local</span>
    </div>

    <div class="container">

        <!-- MODE SELECTION SCREEN -->
        <div id="modeSelectionScreen" class="screen active">
            <div class="header">
                <h1>Four4More V5.1.19</h1>
                <p class="subtitle">Multiplayer</p>
            </div>

            <div class="setup-content">
                <h2 style="color: #764ba2; margin-bottom: 30px;">How do you want to play?</h2>

                <button class="btn btn-primary" onclick="selectGameMode('local')"
                        style="width: 100%; margin: 15px 0; padding: 25px; font-size: 18px;">
                    🏠 Local Multiplayer
                    <div style="font-size: 14px; margin-top: 8px; opacity: 0.9; font-weight: normal;">
                        Play on this device (pass and play)
                    </div>
                </button>

                <button class="btn btn-primary" onclick="window.open('multiplayer.html?mode=online&v=42', '_blank')"
                        style="width: 100%; margin: 15px 0; padding: 25px; font-size: 18px;">
                    🌐 Online Multiplayer
                    <div style="font-size: 14px; margin-top: 8px; opacity: 0.9; font-weight: normal;">
                        Play with friends on different devices
                    </div>
                </button>

                <button class="btn btn-secondary" onclick="runAutomatedQA()"
                        style="width: 100%; margin: 30px 0 10px 0; padding: 20px; font-size: 16px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);">
                    🧪 Run QA Tests
                    <div style="font-size: 13px; margin-top: 8px; opacity: 0.9; font-weight: normal;">
                        Automated test suite (check console)
                    </div>
                </button>

                <button class="btn btn-primary" onclick="runFullGameTestUI()"
                        style="width: 100%; margin: 10px 0 15px 0; padding: 20px; font-size: 16px; background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);">
                    🎮 Run Full Game Test
                    <div style="font-size: 13px; margin-top: 8px; opacity: 0.9; font-weight: normal;">
                        3 players, 5 rounds (~60 seconds)
                    </div>
                </button>

                <div style="background: #f0f0f0; padding: 20px; border-radius: 10px;
                           margin-top: 30px; font-size: 14px; line-height: 1.6;">
                    <div style="margin-bottom: 15px;">
                        <strong>🏠 Local Multiplayer:</strong><br>
                        • Play on this device<br>
                        • Pass and play between players<br>
                        • No internet required<br>
                        • Great for family game nights
                    </div>
                    <div>
                        <strong>🌐 Online Multiplayer:</strong><br>
                        • Each player on their own device<br>
                        • Play with friends anywhere<br>
                        • Internet required<br>
                        • Create or join with room code
                    </div>
                </div>
            </div>
        </div>

        <!-- ONLINE SETUP SCREEN -->
        <div id="onlineSetupScreen" class="screen">
            <div class="header">
                <h1>Four4More V5.1.19 - Online</h1>
                <p class="subtitle">Connect with Friends</p>
            </div>

            <div class="setup-content">
                <h2 style="color: #764ba2; margin-bottom: 20px;">Join or Create Game</h2>

                <div class="form-group">
                    <label for="playerName">Your Name</label>
                    <input type="text" id="playerName" maxlength="20" placeholder="Enter your name">
                </div>

                <button class="btn btn-primary" onclick="createNewGame()"
                        style="width: 100%; margin: 20px 0;">
                    Create New Game
                </button>

                <div style="text-align: center; margin: 20px 0; color: #666;">
                    - OR -
                </div>

                <div class="form-group">
                    <label for="roomCode">Room Code</label>
                    <input type="text" id="roomCode" maxlength="6" placeholder="Enter 6-character code"
                           style="text-transform: uppercase;">
                </div>

                <button class="btn btn-primary" onclick="joinExistingGame()"
                        style="width: 100%; margin: 10px 0;">
                    Join Game
                </button>

                <button class="btn btn-secondary" onclick="backToModeSelection()"
                        style="width: 100%; margin: 20px 0;">
                    ← Back
                </button>
            </div>
        </div>

        <!-- LOBBY SCREEN (Online Mode) -->
        <div id="lobbyScreen" class="screen">
            <div class="header">
                <h1>Game Lobby</h1>
                <p class="subtitle" id="lobbyRoomCode">Room: ------</p>
            </div>

            <div class="setup-content">
                <h2 style="color: #764ba2; margin-bottom: 20px;">Players</h2>

                <div id="lobbyPlayersList" style="background: #f0f0f0; padding: 15px;
                                                   border-radius: 10px; margin-bottom: 20px;">
                    <!-- Players will be listed here dynamically -->
                </div>

                <div id="hostControls" style="display: none;">
                    <h3 style="color: #764ba2; margin-top: 30px;">Game Settings</h3>

                    <div class="form-group">
                        <label for="maxRounds">Number of Rounds</label>
                        <select id="maxRounds">
                            <option value="3">3 Rounds</option>
                            <option value="5" selected>5 Rounds</option>
                            <option value="7">7 Rounds</option>
                            <option value="10">10 Rounds</option>
                        </select>
                    </div>

                    <button class="btn btn-primary" id="startGameBtn" onclick="startOnlineGame()"
                            style="width: 100%; margin: 20px 0;" disabled>
                        Start Game
                    </button>
                    <div id="startGameHint" style="text-align: center; color: #999; font-size: 13px; margin-top: -10px;">
                        Waiting for at least 1 more player...
                    </div>
                </div>

                <button class="btn btn-secondary" onclick="leaveLobby()"
                        style="width: 100%; margin: 10px 0;">
                    Leave Lobby
                </button>

                <div id="lobbyStatus" style="text-align: center; margin-top: 20px;
                                            color: #666; font-size: 14px;">
                    Waiting for host to start game...
                </div>
            </div>
        </div>

        <!-- LOCAL SETUP SCREEN -->
        <div id="setupScreen" class="screen">
            <div class="header">
                <h1>Outrank V4</h1>
                <p class="subtitle">Draft & Guess - Push Your Luck!</p>
            </div>

            <div class="setup-content">
                <h2 style="color: #764ba2; margin-bottom: 20px;">Game Setup</h2>

                <div class="form-group">
                    <label for="numPlayers">Number of Players (2-6)</label>
                    <select id="numPlayers">
                        <option value="2">2 Players</option>
                        <option value="3" selected>3 Players</option>
                        <option value="4">4 Players</option>
                        <option value="5">5 Players</option>
                        <option value="6">6 Players</option>
                    </select>
                </div>

                <div class="form-group">
                    <label>Player Names</label>
                    <div id="playerInputs" class="player-inputs">
                        <!-- Dynamically generated player inputs -->
                    </div>
                </div>

                <div class="form-group">
                    <label for="firstPlayer">First Guesser</label>
                    <select id="firstPlayer">
                        <option value="0">Youngest Player</option>
                    </select>
                </div>

                <div class="form-group">
                    <label for="numRounds">Number of Rounds</label>
                    <select id="numRounds">
                        <option value="3">3 Rounds</option>
                        <option value="5" selected>5 Rounds</option>
                        <option value="7">7 Rounds</option>
                        <option value="10">10 Rounds</option>
                    </select>
                </div>

                <div class="form-group">
                    <label for="challengeMode">Challenge Selection Mode</label>
                    <select id="challengeMode">
                        <option value="manual">📋 Manual - Choose any challenge</option>
                        <option value="cards" selected>🎴 Challenge Cards - Random draw each round</option>
                    </select>
                    <p style="font-size: 12px; color: #666; margin-top: 5px;">
                        <strong>Manual:</strong> First Guesser picks from all available challenges<br>
                        <strong>Cards:</strong> 1 random challenge per category, First Guesser picks one
                    </p>
                </div>

                <button class="btn btn-primary" style="width: 100%;" onclick="startGame()">Start Game</button>
            </div>
        </div>

        <!-- GAME END SCREEN -->
        <div id="gameEndScreen" class="screen">
            <div class="header">
                <h1>🎉 Game Over! 🎉</h1>
                <p class="subtitle">Final Results</p>
            </div>

            <div class="setup-content">
                <div id="winnerAnnouncement" style="background: linear-gradient(135deg, #667eea, #764ba2); color: white; padding: 30px; border-radius: 15px; margin-bottom: 30px; text-align: center;">
                    <!-- Winner info dynamically inserted -->
                </div>

                <h2 style="color: #764ba2; margin-bottom: 20px;">Final Standings</h2>
                <div id="finalStandings" style="background: white; padding: 20px; border-radius: 15px; margin-bottom: 20px;">
                    <!-- Final standings dynamically inserted -->
                </div>

                <h2 style="color: #764ba2; margin-bottom: 20px;">Game Stats</h2>
                <div id="gameStats" style="background: white; padding: 20px; border-radius: 15px; margin-bottom: 30px;">
                    <!-- Game stats dynamically inserted -->
                </div>

                <button class="btn btn-primary" style="width: 100%; margin-bottom: 10px;" onclick="location.reload()">New Game</button>
            </div>
        </div>

        <!-- GAME SCREEN -->
        <div id="gameScreen" class="screen">
            <!-- LOCKED OUT OVERLAY -->
            <div id="lockedOutOverlay" class="locked-out-overlay">
                <div class="locked-out-message">
                    <h2>⛔ Locked Out</h2>
                    <p>You have passed this round.<br>Wait for the next round to continue playing.</p>
                </div>
            </div>

            <!-- V5.1.14: Top row with banner + challenge info side by side -->
            <div style="display: grid; grid-template-columns: 250px 1fr; gap: 20px; margin-bottom: 20px;">
                <!-- BANNER (same width as player column) -->
                <div class="header panel" style="margin: 0; padding: 15px;">
                    <h1 style="font-size: 1.5em; margin-bottom: 15px;">Four4More V5.1.15</h1>

                    <!-- V5.1.14: Round info at top -->
                    <p class="subtitle" style="font-size: 1em; margin-bottom: 15px; padding-bottom: 10px; border-bottom: 2px solid #f0f0f0;">Round <span id="roundNumber">1</span></p>

                    <!-- V5.1.14: Current turn display -->
                    <p style="font-weight: bold; color: #764ba2; margin-bottom: 10px; font-size: 0.95em;">Current Turn:</p>
                    <p id="playerNameDisplay" style="font-weight: bold; color: #667eea; margin-bottom: 15px; font-size: 1em;">Loading...</p>

                    <!-- V5.1.14: Action buttons (moved from bottom) -->
                    <div style="display: flex; flex-direction: column; gap: 8px;">
                        <button id="cashOutBtn" class="btn btn-secondary" onclick="openCashOutModal()" disabled style="width: 100%; padding: 10px; font-size: 0.9em;">💰 Cash Out</button>
                        <button id="playCardBtn" class="btn btn-secondary" onclick="openPlayCardModal()" disabled style="width: 100%; padding: 10px; font-size: 0.9em;">🎴 Play Card</button>
                        <button id="passBtn" class="btn btn-secondary" onclick="passRound()" style="width: 100%; padding: 10px; font-size: 0.9em;">⏩ Pass</button>
                    </div>
                </div>

                <!-- CHALLENGE INFO (same level as banner) -->
                <div id="challengeInfo" class="panel" style="display: none; margin: 0; position: relative; padding: 15px 100px; padding-bottom: 70px;">
                    <h2 id="challengeName" style="margin-bottom: 5px; font-size: 1.3em;">Movies - Box Office</h2>
                    <p class="stat-name" id="statName" style="margin: 0; font-size: 1em; color: #764ba2;">Higher or Lower</p>
                    <p class="token-carryover-info" id="tokenCarryoverInfo" style="display: none; font-size: 0.9em; color: #ffd700; margin-top: 5px; font-weight: bold;"></p>

                    <!-- V5.1.14: CENTER TOKEN (moved inside challenge panel) -->
                    <div id="centerTokenArea" class="center-token-area" style="display: none; margin-top: 15px;">
                        <h3 style="font-size: 1.1em; margin-bottom: 10px;">Center Token</h3>
                        <div id="centerToken" class="center-token">
                            <!-- Token content -->
                        </div>
                    </div>

                    <!-- V5.1.14: GUESS BUTTONS (positioned at vertical center of card) -->
                    <!-- LOWER section (left side) -->
                    <div id="guessArea" style="display: none;">
                        <div style="position: absolute; left: 15px; top: 50%; transform: translateY(-50%); display: flex; flex-direction: column; align-items: center; gap: 10px;">
                            <strong id="draftedTokenName" style="font-size: 1.3em; color: #764ba2; white-space: nowrap; font-weight: bold;">Select token</strong>
                            <button class="btn btn-danger" onclick="makeGuess('lower')" style="padding: 18px 28px; font-size: 1.2em; font-weight: bold; white-space: nowrap;">
                                📉 LOWER
                            </button>
                        </div>

                        <!-- HIGHER section (right side) -->
                        <div style="position: absolute; right: 15px; top: 50%; transform: translateY(-50%); display: flex; flex-direction: column; align-items: center; gap: 10px;">
                            <strong id="draftedTokenName2" style="font-size: 1.3em; color: #764ba2; white-space: nowrap; font-weight: bold;">Select token</strong>
                            <button class="btn btn-success" onclick="makeGuess('higher')" style="padding: 18px 28px; font-size: 1.2em; font-weight: bold; white-space: nowrap;">
                                📈 HIGHER
                            </button>
                        </div>
                    </div>

                    <!-- V5.1.14: Toggle Data Button (moved inside challenge panel) -->
                    <button id="toggleDataBtn" class="btn btn-secondary" style="position: absolute; bottom: 15px; right: 15px; padding: 8px 15px; font-size: 0.9em;" onclick="toggleDataVisibility()">
                        👁️ Hide Data
                    </button>
                </div>
            </div>

            <div class="game-layout">
                <!-- PLAYERS PANEL -->
                <div class="panel">
                    <h2>Players</h2>
                    <div id="playersList">
                        <!-- Dynamically populated player info -->
                    </div>
                </div>

                <!-- MAIN GAME AREA -->
                <div>

                    <!-- V5.1.14: BONUS CARD POOL (moved to top) -->
                    <div class="panel" style="margin-top: 0; margin-bottom: 15px;">
                        <h2>🎴 Bonus Cards</h2>
                        <p style="font-size: 0.9em; color: #666; margin-bottom: 10px;">Choose 1 card when you cash in tokens</p>
                        <div id="bonusCardPool" class="bonus-card-pool">
                            <!-- Dynamically populated cards -->
                        </div>
                    </div>

                    <!-- DRAFT POOL -->
                    <div class="panel">
                        <h2>Draft Pool (<span id="poolCount">12</span> tokens)</h2>
                        <div id="draftPool" class="draft-pool">
                            <!-- Dynamically populated tokens -->
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- CASH OUT MODAL -->
        <div id="cashOutModal" class="modal">
            <div class="modal-content">
                <h2>Cash Out Sets</h2>
                <div id="cashOutContent">
                    <!-- Dynamically populated sets -->
                </div>
                <div style="display: flex; gap: 10px; margin-top: 20px;">
                    <button class="btn btn-primary" onclick="executeCashOut()">Confirm Cash Out</button>
                    <button class="btn btn-secondary" onclick="closeCashOutModal()">Cancel</button>
                </div>
            </div>
        </div>

        <!-- CATEGORY SELECTION MODAL -->
        <div id="categoryModal" class="modal">
            <div class="modal-content">
                <h2>Select Category & Challenge</h2>
                <p style="margin-bottom: 20px;"><strong id="firstGuesserName"></strong>, choose a category and challenge for this round:</p>

                <div class="form-group">
                    <label>Category:</label>
                    <select id="categorySelect" onchange="updateChallengeOptions()">
                        <option value="">-- Select Category --</option>
                        <option value="movies">🎬 Movies</option>
                        <option value="countries">🌍 Countries</option>
                        <option value="companies">🏢 Companies</option>
                        <option value="sports">🏈 Sports</option>
                    </select>
                </div>

                <div class="form-group">
                    <label>Challenge:</label>
                    <select id="challengeSelect">
                        <option value="">-- Select Challenge --</option>
                    </select>
                </div>

                <div id="categoryWarning" style="display: none; background: #fff3cd; padding: 15px; border-radius: 8px; margin: 15px 0; color: #856404;">
                    ⚠️ This category has fewer than 13 tokens remaining. Choose another category.
                </div>

                <button class="btn btn-primary" onclick="confirmCategorySelection()" style="width: 100%; margin-top: 20px;">Start Round</button>
            </div>
        </div>

        <!-- LOCKED OUT MODAL -->
        <div id="lockedOutModal" class="modal">
            <div class="modal-content">
                <h2>❌ Locked Out!</h2>
                <p id="lockedOutMessage" style="text-align: center; font-size: 1.2em; margin: 20px 0;">
                    You guessed incorrectly and are locked out for the rest of this round.
                </p>
                <p style="text-align: center; color: #666; font-size: 0.9em; margin-top: 20px;">
                    This modal will close automatically...
                </p>
            </div>
        </div>

        <!-- V5.0: BONUS CARD PICK MODAL -->
        <div id="bonusCardPickModal" class="modal">
            <div class="modal-content" style="max-width: 500px;">
                <h2>🎴 Choose Bonus Card</h2>
                <div id="bonusCardPickContent">
                    <!-- Dynamically populated cards -->
                </div>
            </div>
        </div>

        <!-- V5.0.3: PLAY CARD MODAL -->
        <div id="playCardModal" class="modal">
            <div class="modal-content" style="max-width: 500px;">
                <h2>🎴 Play a Card</h2>
                <p style="margin-bottom: 15px; color: #666;">Select a card to play from your hand</p>
                <div id="playCardContent">
                    <!-- Dynamically populated playable cards -->
                </div>
                <button class="btn btn-secondary" onclick="closePlayCardModal()" style="width: 100%; margin-top: 15px;">Cancel</button>
            </div>
        </div>

        <!-- V5.0.6: DISCARD CARD MODAL -->
        <div id="discardCardModal" class="modal">
            <div class="modal-content" style="max-width: 500px;">
                <h2>⚠️ Hand Limit Reached</h2>
                <p style="margin-bottom: 15px; color: #666;">You have 4 cards (max). Choose a card to discard:</p>
                <div id="discardCardContent">
                    <!-- Dynamically populated cards to discard -->
                </div>
            </div>
        </div>

        <!-- Token Selection Modal (v5.1.0) -->
        <div id="tokenSelectionModal" class="modal">
            <div class="modal-content" style="max-width: 600px;">
                <h2 id="tokenSelectionTitle">🎯 Select Token</h2>
                <p id="tokenSelectionInstructions" style="margin-bottom: 15px; color: #666;">Choose a token:</p>
                <div id="tokenSelectionContent" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); gap: 10px; margin-bottom: 20px;">
                    <!-- Dynamically populated tokens to select -->
                </div>
                <button class="btn btn-secondary" onclick="closeTokenSelectionModal()" style="width: 100%;">Cancel</button>
            </div>
        </div>

    </div>

    <script>
        // ===== GAME STATE =====
        const gameState = {
            phase: 'setup',
            round: 0,
            maxRounds: 5,
            challengeMode: 'cards', // 'manual' or 'cards'
            drawnChallengeCards: [], // Array of {challenge, roundsAvailable} objects
            currentPlayer: 0,
            firstGuesser: 0,
            players: [],
            // V5.1.19: Per-category draft pools and center tokens (persist across rounds)
            centerToken: null, // DEPRECATED - use categoryCenterTokens instead
            draftPool: [], // DEPRECATED - use categoryDraftPools instead
            categoryCenterTokens: {
                movies: null,
                countries: null,
                companies: null,
                sports: null
            },
            categoryDraftPools: {
                movies: [],
                countries: [],
                companies: [],
                sports: []
            },
            categoryPools: {
                movies: [],
                countries: [],
                companies: [],
                sports: []
            },
            selectedCategory: null,
            previousCategory: null, // Track previous category for token persistence
            playedChallenges: [], // Track challenges that have been played this game
            retiredTokens: [],
            passedPlayers: new Set(), // Players who passed this round
            lockedOutPlayers: new Set(), // V4.97: Players locked out this round (passed OR picked wrong)
            lastPlayerToAct: null, // V4.97: Track who took the last turn (for +1 bonus)
            currentChallenge: null,
            selectedDraftToken: null,
            // V5.0: Bonus Card System
            bonusCardDeck: [],        // Cards not yet in pool (shuffled at game start)
            bonusCardPool: [],        // 3 cards visible to all players
            bonusCardsInPlay: []      // All cards currently held by players
        };

        // V5.1.19: Helper functions for category-specific draft pools/center tokens
        // These maintain backwards compatibility while allowing per-category persistence
        function getCurrentCenterToken() {
            const category = gameState.selectedCategory || gameState.previousCategory;
            return category ? gameState.categoryCenterTokens[category] : gameState.centerToken;
        }

        function setCurrentCenterToken(token) {
            const category = gameState.selectedCategory || gameState.previousCategory;
            if (category) {
                gameState.categoryCenterTokens[category] = token;
            }
            gameState.centerToken = token; // Keep legacy field updated for compatibility
        }

        function getCurrentDraftPool() {
            const category = gameState.selectedCategory || gameState.previousCategory;
            return category ? gameState.categoryDraftPools[category] : gameState.draftPool;
        }

        function setCurrentDraftPool(tokens) {
            const category = gameState.selectedCategory || gameState.previousCategory;
            if (category) {
                gameState.categoryDraftPools[category] = tokens;
            }
            gameState.draftPool = tokens; // Keep legacy field updated for compatibility
        }

        // ===== TOKEN DATABASE =====
        // Token data loaded from v4_token_datasets.js
        // MOVIES_TOKENS, COUNTRIES_TOKENS, COMPANIES_TOKENS, SPORTS_TOKENS are globally available
        // Total: 244 tokens across 4 categories

        // ===== BONUS CARD DATABASE (V5.0) =====
        const BONUS_CARDS = [
            // IMMEDIATE POINTS - Activate instantly when picked
            { id: 'INSTANT_3', name: '💰 Quick Cash', type: 'immediate', effect: 'points', value: 3, description: 'Gain 3 points immediately' },
            { id: 'INSTANT_5', name: '💎 Jackpot', type: 'immediate', effect: 'points', value: 5, description: 'Gain 5 points immediately' },
            { id: 'INSTANT_2', name: '🪙 Small Bonus', type: 'immediate', effect: 'points', value: 2, description: 'Gain 2 points immediately' },

            // SCORE MULTIPLIERS - Play before cash-in to multiply points
            { id: 'DOUBLE_NEXT', name: '✨ Double Down', type: 'playable', effect: 'multiplier', value: 2, description: 'Play before cash-in: Double the points earned' },
            { id: 'TRIPLE_NEXT', name: '🌟 Triple Threat', type: 'playable', effect: 'multiplier', value: 3, description: 'Play before cash-in: Triple the points earned' },

            // TOKEN MANIPULATION - Play on your turn
            { id: 'STEAL_TOKEN', name: '🎯 Snatch', type: 'playable', effect: 'steal', description: 'Steal 1 token from draft pool to your hand' },
            { id: 'EXTRA_DRAW', name: '🎴 Double Pick', type: 'playable', effect: 'draw', value: 2, description: 'Draw 2 extra tokens from draft pool' },
            { id: 'RETURN_TOKEN', name: '♻️ Saboteur', type: 'playable', effect: 'return_opponent', description: 'Return 1 token from any opponent\'s hand to draft pool' },

            // DEFENSIVE - Play to block opponents
            { id: 'BLOCK_CASHOUT', name: '🛡️ Veto', type: 'playable', effect: 'block', description: 'Block the next opponent cash-in attempt' },
            { id: 'FORCE_DISCARD', name: '💣 Sabotage', type: 'playable', effect: 'discard', description: 'Force target opponent to discard 2 tokens' },

            // END-GAME BONUSES - Score at game end
            { id: 'TOKEN_HOARDER', name: '🗃️ Collector', type: 'endgame', effect: 'token_count', value: 1, description: 'Endgame: +1 point per token in hand' },
            { id: 'CASHOUT_MASTER', name: '🏆 Cash King', type: 'endgame', effect: 'cashout_count', value: 2, description: 'Endgame: +2 points per cash-in made' },
            { id: 'CARD_COLLECTOR', name: '🃏 Card Shark', type: 'endgame', effect: 'card_count', value: 3, description: 'Endgame: +3 points per bonus card held' },

            // WILDCARDS - Flexible tag matching
            { id: 'TAG_WILD_1', name: '🌈 Wild Card', type: 'playable', effect: 'wildcard', uses: 1, description: 'Treat 1 token as any tag for one cash-in' },
            { id: 'TAG_WILD_2', name: '🎨 Rainbow', type: 'playable', effect: 'wildcard', uses: 2, description: 'Treat 1 token as any tag (2 uses)' },

            // PASSIVE EFFECTS - Always active once acquired
            { id: 'BONUS_GUESS', name: '🧠 Genius', type: 'passive', effect: 'guess_bonus', value: 1, description: 'Passive: +1 point for every correct guess' },
            { id: 'LUCKY_DRAW', name: '🍀 Lucky', type: 'passive', effect: 'draw_bonus', description: 'Passive: Draw 1 extra token each turn' },

            // SPECIAL ACTIONS
            { id: 'SWAP_TOKENS', name: '🔄 Trade', type: 'playable', effect: 'swap', description: 'Swap 1 of your tokens with 1 from draft pool' }
        ];

        console.log('🎴 Bonus card database loaded:', BONUS_CARDS.length, 'cards');

        // Fallback placeholder data (will be replaced by external file)
        const MOVIE_TOKENS_FALLBACK = [
            { id: 'AVATAR', name: 'Avatar', tags: ['A1', 'B3', 'C1', 'D2'], stats: { boxOffice: 2923706000 } },
            { id: 'AVENGERS_ENDGAME', name: 'Avengers: Endgame', tags: ['A2', 'B3', 'C1', 'D3'], stats: { boxOffice: 2799439100 } },
            { id: 'AVATAR_2', name: 'Avatar: The Way of Water', tags: ['A2', 'B3', 'C1', 'D2'], stats: { boxOffice: 2320250281 } },
            { id: 'TITANIC', name: 'Titanic', tags: ['A2', 'B2', 'C2', 'D1'], stats: { boxOffice: 2257844554 } },
            { id: 'STAR_WARS_7', name: 'Star Wars: The Force Awakens', tags: ['A2', 'B3', 'C1', 'D3'], stats: { boxOffice: 2071310218 } },
            { id: 'AVENGERS_INFINITY_WAR', name: 'Avengers: Infinity War', tags: ['A2', 'B3', 'C1', 'D3'], stats: { boxOffice: 2052415039 } },
            { id: 'SPIDER_MAN_NWH', name: 'Spider-Man: No Way Home', tags: ['A2', 'B2', 'C1', 'D3'], stats: { boxOffice: 1921847111 } },
            { id: 'JURASSIC_WORLD', name: 'Jurassic World', tags: ['A2', 'B2', 'C1', 'D3'], stats: { boxOffice: 1671537444 } },
            { id: 'LION_KING', name: 'The Lion King', tags: ['A1', 'B2', 'C4', 'D4'], stats: { boxOffice: 1663075401 } },
            { id: 'AVENGERS', name: 'The Avengers', tags: ['A2', 'B2', 'C1', 'D3'], stats: { boxOffice: 1520538536 } },
            { id: 'FURIOUS_7', name: 'Furious 7', tags: ['A2', 'B2', 'C1', 'D3'], stats: { boxOffice: 1515341399 } },
            { id: 'TOP_GUN_MAVERICK', name: 'Top Gun: Maverick', tags: ['A2', 'B2', 'C1', 'D3'], stats: { boxOffice: 1495696292 } },
            { id: 'FROZEN_2', name: 'Frozen II', tags: ['A1', 'B2', 'C4', 'D4'], stats: { boxOffice: 1453683476 } },
            { id: 'BARBIE', name: 'Barbie', tags: ['A2', 'B2', 'C3', 'D4'], stats: { boxOffice: 1445638421 } },
            { id: 'AVENGERS_AGE_OF_ULTRON', name: 'Avengers: Age of Ultron', tags: ['A2', 'B3', 'C1', 'D3'], stats: { boxOffice: 1405035767 } },
            { id: 'BLACK_PANTHER', name: 'Black Panther', tags: ['A2', 'B2', 'C1', 'D3'], stats: { boxOffice: 1347597973 } },
            { id: 'HARRY_POTTER_7P2', name: 'Harry Potter and the Deathly Hallows Part 2', tags: ['A2', 'B2', 'C4', 'D4'], stats: { boxOffice: 1342321665 } },
            { id: 'STAR_WARS_8', name: 'Star Wars: The Last Jedi', tags: ['A2', 'B2', 'C1', 'D3'], stats: { boxOffice: 1334407706 } },
            { id: 'JURASSIC_WORLD_FALLEN', name: 'Jurassic World: Fallen Kingdom', tags: ['A2', 'B2', 'C1', 'D3'], stats: { boxOffice: 1310466296 } },
            { id: 'FROZEN', name: 'Frozen', tags: ['A1', 'B2', 'C4', 'D1'], stats: { boxOffice: 1290000000 } },
            { id: 'BEAUTY_AND_BEAST', name: 'Beauty and the Beast', tags: ['A1', 'B2', 'C4', 'D4'], stats: { boxOffice: 1266115964 } },
            { id: 'INCREDIBLES_2', name: 'Incredibles 2', tags: ['A1', 'B2', 'C4', 'D1'], stats: { boxOffice: 1243225667 } },
            { id: 'FATE_OF_FURIOUS', name: 'The Fate of the Furious', tags: ['A2', 'B3', 'C1', 'D3'], stats: { boxOffice: 1236005118 } },
            { id: 'IRON_MAN_3', name: 'Iron Man 3', tags: ['A2', 'B2', 'C1', 'D3'], stats: { boxOffice: 1215439994 } },
            { id: 'MINIONS', name: 'Minions', tags: ['A1', 'B1', 'C4', 'D4'], stats: { boxOffice: 1159457503 } },
            { id: 'CAPTAIN_AMERICA_3', name: 'Captain America: Civil War', tags: ['A2', 'B3', 'C1', 'D3'], stats: { boxOffice: 1155046416 } },
            { id: 'AQUAMAN', name: 'Aquaman', tags: ['A2', 'B2', 'C1', 'D3'], stats: { boxOffice: 1152028393 } },
            { id: 'LORD_OF_RINGS_3', name: 'The Lord of the Rings: The Return of the King', tags: ['A2', 'B3', 'C4', 'D4'], stats: { boxOffice: 1146030912 } },
            { id: 'SPIDER_MAN_FFH', name: 'Spider-Man: Far From Home', tags: ['A2', 'B2', 'C1', 'D3'], stats: { boxOffice: 1131927996 } },
            { id: 'CAPTAIN_MARVEL', name: 'Captain Marvel', tags: ['A2', 'B2', 'C1', 'D3'], stats: { boxOffice: 1131416446 } },
            { id: 'TRANSFORMERS_3', name: 'Transformers: Dark of the Moon', tags: ['A2', 'B3', 'C1', 'D4'], stats: { boxOffice: 1123794079 } },
            { id: 'SKYFALL', name: 'Skyfall', tags: ['A2', 'B2', 'C1', 'D4'], stats: { boxOffice: 1108561013 } },
            { id: 'TRANSFORMERS_4', name: 'Transformers: Age of Extinction', tags: ['A2', 'B3', 'C1', 'D4'], stats: { boxOffice: 1104054072 } },
            { id: 'DARK_KNIGHT_RISES', name: 'The Dark Knight Rises', tags: ['A2', 'B3', 'C1', 'D3'], stats: { boxOffice: 1085276260 } },
            { id: 'JOKER', name: 'Joker', tags: ['A3', 'B1', 'C2', 'D1'], stats: { boxOffice: 1078958629 } },
            { id: 'STAR_WARS_9', name: 'Star Wars: The Rise of Skywalker', tags: ['A2', 'B3', 'C1', 'D3'], stats: { boxOffice: 1077022372 } },
            { id: 'TOY_STORY_4', name: 'Toy Story 4', tags: ['A1', 'B2', 'C4', 'D3'], stats: { boxOffice: 1073064540 } },
            { id: 'TOY_STORY_3', name: 'Toy Story 3', tags: ['A1', 'B2', 'C4', 'D3'], stats: { boxOffice: 1067316101 } },
            { id: 'PIRATES_4', name: 'Pirates of the Caribbean: On Stranger Tides', tags: ['A2', 'B3', 'C4', 'D3'], stats: { boxOffice: 1046721266 } },
            { id: 'DESPICABLE_ME_3', name: 'Despicable Me 3', tags: ['A1', 'B1', 'C4', 'D3'], stats: { boxOffice: 1034800131 } }
        ];

        // Tag Legend:
        // A1 = G, A2 = PG-13, A3 = R
        // B1 = Low Budget, B2 = Medium Budget, B3 = Ultra Budget
        // C1 = Action, C2 = Drama, C3 = Comedy, C4 = Fantasy/Animation
        // D1 = Original, D2 = Standalone, D3 = Franchise, D4 = Adaptation

        // ===== COUNTRY TOKENS =====
        const COUNTRY_TOKENS = [
            { id: 'USA', name: 'United States', tags: ['A1', 'B3', 'C1', 'D3'], stats: { gdp: 25462700000000, population: 331900000 } },
            { id: 'CHN', name: 'China', tags: ['A1', 'B3', 'C2', 'D3'], stats: { gdp: 17963000000000, population: 1412000000 } },
            { id: 'JPN', name: 'Japan', tags: ['A1', 'B2', 'C1', 'D2'], stats: { gdp: 4231000000000, population: 125700000 } },
            { id: 'DEU', name: 'Germany', tags: ['A2', 'B2', 'C1', 'D2'], stats: { gdp: 4073000000000, population: 83200000 } },
            { id: 'IND', name: 'India', tags: ['A1', 'B2', 'C2', 'D3'], stats: { gdp: 3469000000000, population: 1393000000 } },
            { id: 'GBR', name: 'United Kingdom', tags: ['A2', 'B2', 'C1', 'D2'], stats: { gdp: 3071000000000, population: 67330000 } },
            { id: 'FRA', name: 'France', tags: ['A2', 'B2', 'C1', 'D2'], stats: { gdp: 2783000000000, population: 67750000 } },
            { id: 'ITA', name: 'Italy', tags: ['A2', 'B2', 'C1', 'D2'], stats: { gdp: 2012000000000, population: 59110000 } },
            { id: 'CAN', name: 'Canada', tags: ['A1', 'B2', 'C1', 'D1'], stats: { gdp: 1991000000000, population: 38250000 } },
            { id: 'KOR', name: 'South Korea', tags: ['A1', 'B2', 'C1', 'D2'], stats: { gdp: 1811000000000, population: 51780000 } },
            { id: 'RUS', name: 'Russia', tags: ['A2', 'B2', 'C2', 'D3'], stats: { gdp: 1778000000000, population: 144100000 } },
            { id: 'BRA', name: 'Brazil', tags: ['A3', 'B2', 'C2', 'D3'], stats: { gdp: 1609000000000, population: 214300000 } },
            { id: 'AUS', name: 'Australia', tags: ['A1', 'B1', 'C1', 'D1'], stats: { gdp: 1553000000000, population: 25690000 } },
            { id: 'ESP', name: 'Spain', tags: ['A2', 'B2', 'C1', 'D2'], stats: { gdp: 1397000000000, population: 47420000 } },
            { id: 'MEX', name: 'Mexico', tags: ['A3', 'B1', 'C2', 'D3'], stats: { gdp: 1294000000000, population: 126700000 } },
            { id: 'IDN', name: 'Indonesia', tags: ['A3', 'B2', 'C2', 'D3'], stats: { gdp: 1186000000000, population: 273800000 } },
            { id: 'NLD', name: 'Netherlands', tags: ['A2', 'B1', 'C1', 'D2'], stats: { gdp: 1012000000000, population: 17530000 } },
            { id: 'SAU', name: 'Saudi Arabia', tags: ['A3', 'B1', 'C3', 'D4'], stats: { gdp: 833000000000, population: 35950000 } },
            { id: 'TUR', name: 'Turkey', tags: ['A3', 'B2', 'C2', 'D3'], stats: { gdp: 819000000000, population: 84780000 } },
            { id: 'CHE', name: 'Switzerland', tags: ['A2', 'B1', 'C1', 'D1'], stats: { gdp: 818000000000, population: 8703000 } },
            { id: 'POL', name: 'Poland', tags: ['A2', 'B1', 'C1', 'D2'], stats: { gdp: 688000000000, population: 37840000 } },
            { id: 'ARG', name: 'Argentina', tags: ['A3', 'B1', 'C2', 'D3'], stats: { gdp: 487000000000, population: 45810000 } },
            { id: 'SWE', name: 'Sweden', tags: ['A2', 'B1', 'C1', 'D1'], stats: { gdp: 585000000000, population: 10420000 } },
            { id: 'BEL', name: 'Belgium', tags: ['A2', 'B1', 'C1', 'D2'], stats: { gdp: 578000000000, population: 11590000 } },
            { id: 'THA', name: 'Thailand', tags: ['A3', 'B1', 'C2', 'D3'], stats: { gdp: 505000000000, population: 71600000 } },
            { id: 'NGA', name: 'Nigeria', tags: ['A4', 'B1', 'C3', 'D4'], stats: { gdp: 477000000000, population: 211400000 } },
            { id: 'AUT', name: 'Austria', tags: ['A2', 'B1', 'C1', 'D2'], stats: { gdp: 476000000000, population: 8917000 } },
            { id: 'NOR', name: 'Norway', tags: ['A2', 'B1', 'C1', 'D1'], stats: { gdp: 482000000000, population: 5465000 } },
            { id: 'IRL', name: 'Ireland', tags: ['A2', 'B1', 'C1', 'D2'], stats: { gdp: 504000000000, population: 5033000 } },
            { id: 'ISR', name: 'Israel', tags: ['A3', 'B1', 'C3', 'D3'], stats: { gdp: 488000000000, population: 9365000 } },
            { id: 'SGP', name: 'Singapore', tags: ['A1', 'B1', 'C1', 'D2'], stats: { gdp: 397000000000, population: 5454000 } },
            { id: 'PHL', name: 'Philippines', tags: ['A3', 'B1', 'C2', 'D3'], stats: { gdp: 404000000000, population: 111000000 } },
            { id: 'MYS', name: 'Malaysia', tags: ['A3', 'B1', 'C2', 'D3'], stats: { gdp: 373000000000, population: 32780000 } },
            { id: 'ZAF', name: 'South Africa', tags: ['A4', 'B1', 'C3', 'D4'], stats: { gdp: 419000000000, population: 60040000 } },
            { id: 'DNK', name: 'Denmark', tags: ['A2', 'B1', 'C1', 'D1'], stats: { gdp: 391000000000, population: 5857000 } },
            { id: 'VNM', name: 'Vietnam', tags: ['A3', 'B1', 'C2', 'D4'], stats: { gdp: 366000000000, population: 98170000 } },
            { id: 'EGY', name: 'Egypt', tags: ['A4', 'B1', 'C3', 'D4'], stats: { gdp: 378000000000, population: 104300000 } },
            { id: 'PAK', name: 'Pakistan', tags: ['A4', 'B1', 'C3', 'D4'], stats: { gdp_total: 347000000000, population_total: 225200000 } },
            { id: 'CHL', name: 'Chile', tags: ['A3', 'B1', 'C2', 'D3'], stats: { gdp_total: 301000000000, population_total: 19210000 } },
            { id: 'FIN', name: 'Finland', tags: ['A2', 'B1', 'C1', 'D1'], stats: { gdp_total: 297000000000, population_total: 5541000 } }
        ];

        // Rename fallback for consistency
        const COUNTRY_TOKENS_FALLBACK = COUNTRY_TOKENS;

        // Country Tag Legend:
        // A1 = Developed (High HDI), A2 = Europe, A3 = Emerging, A4 = Developing
        // B1 = Small Economy, B2 = Large Economy, B3 = Superpower Economy
        // C1 = Democratic, C2 = Mixed, C3 = Authoritarian, C4 = Other
        // D1 = Low Density, D2 = Medium Density, D3 = High Density, D4 = Very High Density

        // ===== CHALLENGES ===== (120 total from data.js)
        const CHALLENGES = [
            // Countries (32 challenges)
            { category: 'countries', stat: 'gdp_total', name: 'GDP Total', direction: 'higher' },
            { category: 'countries', stat: 'gdp_growth_pct', name: 'GDP Growth %', direction: 'higher' },
            { category: 'countries', stat: 'unemployment_rate', name: 'Unemployment Rate', direction: 'lower' },
            { category: 'countries', stat: 'health_expenditure_pct_gdp', name: 'Health Spending % GDP', direction: 'higher' },
            { category: 'countries', stat: 'healthy_diet_cost_ppp', name: 'Healthy Diet Cost', direction: 'lower' },
            { category: 'countries', stat: 'patent_applications', name: 'Patent Applications', direction: 'higher' },
            { category: 'countries', stat: 'female_labor_participation_pct', name: 'Female Labor %', direction: 'higher' },
            { category: 'countries', stat: 'population_total', name: 'Population Total', direction: 'higher' },
            { category: 'countries', stat: 'population_0_14_pct', name: 'Population 0-14 %', direction: 'higher' },
            { category: 'countries', stat: 'population_65_plus_pct', name: 'Population 65+ %', direction: 'higher' },
            { category: 'countries', stat: 'birth_rate', name: 'Birth Rate', direction: 'higher' },
            { category: 'countries', stat: 'life_expectancy', name: 'Life Expectancy', direction: 'higher' },
            { category: 'countries', stat: 'rural_population_pct', name: 'Rural Population %', direction: 'higher' },
            { category: 'countries', stat: 'broadband_per_100', name: 'Broadband per 100', direction: 'higher' },
            { category: 'countries', stat: 'mobile_per_100', name: 'Mobile per 100', direction: 'higher' },
            { category: 'countries', stat: 'secure_servers_per_1m', name: 'Secure Servers per 1M', direction: 'higher' },
            { category: 'countries', stat: 'forest_area_pct', name: 'Forest Area %', direction: 'higher' },
            { category: 'countries', stat: 'renewable_energy_pct', name: 'Renewable Energy %', direction: 'higher' },
            { category: 'countries', stat: 'electricity_coal_pct', name: 'Electricity Coal %', direction: 'lower' },
            { category: 'countries', stat: 'electricity_oil_pct', name: 'Electricity Oil %', direction: 'lower' },
            { category: 'countries', stat: 'pollution_index', name: 'Pollution Index', direction: 'lower' },
            { category: 'countries', stat: 'irrigated_land_km2', name: 'Irrigated Land km²', direction: 'higher' },
            { category: 'countries', stat: 'soybean_production_tonnes', name: 'Soybean Production', direction: 'higher' },
            { category: 'countries', stat: 'airports', name: 'Airports', direction: 'higher' },
            { category: 'countries', stat: 'unesco_total_sites', name: 'UNESCO Total Sites', direction: 'higher' },
            { category: 'countries', stat: 'unesco_cultural_sites', name: 'UNESCO Cultural Sites', direction: 'higher' },
            { category: 'countries', stat: 'unesco_natural_sites', name: 'UNESCO Natural Sites', direction: 'higher' },
            { category: 'countries', stat: 'unesco_mixed_sites', name: 'UNESCO Mixed Sites', direction: 'higher' },
            { category: 'countries', stat: 'tertiary_enrollment_pct', name: 'Tertiary Enrollment %', direction: 'higher' },
            { category: 'countries', stat: 'nobel_laureates', name: 'Nobel Laureates', direction: 'higher' },
            { category: 'countries', stat: 'crime_index', name: 'Crime Index', direction: 'lower' },
            { category: 'countries', stat: 'life_evaluation', name: 'Life Evaluation', direction: 'higher' },

            // Movies (33 challenges)
            { category: 'movies', stat: 'box_office_gross', name: 'Box Office Gross', direction: 'higher' },
            { category: 'movies', stat: 'production_budget', name: 'Production Budget', direction: 'higher' },
            { category: 'movies', stat: 'runtime_minutes', name: 'Runtime', direction: 'higher' },
            { category: 'movies', stat: 'imdb_rating', name: 'IMDb Rating', direction: 'higher' },
            { category: 'movies', stat: 'rotten_tomatoes', name: 'Rotten Tomatoes', direction: 'higher' },
            { category: 'movies', stat: 'metacritic_score', name: 'Metacritic Score', direction: 'higher' },
            { category: 'movies', stat: 'release_year', name: 'Release Year', direction: 'higher' },
            { category: 'movies', stat: 'opening_weekend', name: 'Opening Weekend', direction: 'higher' },
            { category: 'movies', stat: 'international_gross', name: 'International Gross', direction: 'higher' },
            { category: 'movies', stat: 'oscar_nominations', name: 'Oscar Nominations', direction: 'higher' },
            { category: 'movies', stat: 'oscar_wins', name: 'Oscar Wins', direction: 'higher' },
            { category: 'movies', stat: 'screen_count', name: 'Screen Count', direction: 'higher' },
            { category: 'movies', stat: 'marketing_budget', name: 'Marketing Budget', direction: 'higher' },
            { category: 'movies', stat: 'profit_margin', name: 'Profit Margin', direction: 'higher' },
            { category: 'movies', stat: 'weeks_in_theaters', name: 'Weeks in Theaters', direction: 'higher' },
            { category: 'movies', stat: 'dvd_sales', name: 'DVD Sales', direction: 'higher' },
            { category: 'movies', stat: 'streaming_views', name: 'Streaming Views', direction: 'higher' },
            { category: 'movies', stat: 'social_media_mentions', name: 'Social Media Mentions', direction: 'higher' },
            { category: 'movies', stat: 'franchise_value', name: 'Franchise Value', direction: 'higher' },
            { category: 'movies', stat: 'director_previous_hits', name: 'Director Previous Hits', direction: 'higher' },
            { category: 'movies', stat: 'star_power_rating', name: 'Star Power Rating', direction: 'higher' },
            { category: 'movies', stat: 'production_days', name: 'Production Days', direction: 'higher' },
            { category: 'movies', stat: 'cgi_budget', name: 'CGI Budget', direction: 'higher' },
            { category: 'movies', stat: 'soundtrack_sales', name: 'Soundtrack Sales', direction: 'higher' },
            { category: 'movies', stat: 'merchandising_revenue', name: 'Merchandising Revenue', direction: 'higher' },
            { category: 'movies', stat: 'sequel_count', name: 'Sequel Count', direction: 'higher' },
            { category: 'movies', stat: 'remake_count', name: 'Remake Count', direction: 'higher' },
            { category: 'movies', stat: 'cultural_impact_score', name: 'Cultural Impact', direction: 'higher' },
            { category: 'movies', stat: 'box_office_multiple', name: 'Box Office Multiple', direction: 'higher' },
            { category: 'movies', stat: 'award_ceremonies_count', name: 'Award Ceremonies', direction: 'higher' },
            { category: 'movies', stat: 'home_video_revenue', name: 'Home Video Revenue', direction: 'higher' },
            { category: 'movies', stat: 'international_markets', name: 'International Markets', direction: 'higher' },
            { category: 'movies', stat: 'fan_rating_average', name: 'Fan Rating Average', direction: 'higher' },

            // Sports (22 challenges)
            { category: 'sports', stat: 'championship_count', name: 'Championships', direction: 'higher' },
            { category: 'sports', stat: 'all_time_wins', name: 'All-Time Wins', direction: 'higher' },
            { category: 'sports', stat: 'playoff_appearances', name: 'Playoff Appearances', direction: 'higher' },
            { category: 'sports', stat: 'winning_percentage', name: 'Winning Percentage', direction: 'higher' },
            { category: 'sports', stat: 'division_titles', name: 'Division Titles', direction: 'higher' },
            { category: 'sports', stat: 'year_founded', name: 'Year Founded', direction: 'lower' },
            { category: 'sports', stat: 'mvp_awards', name: 'MVP Awards', direction: 'higher' },
            { category: 'sports', stat: 'retired_numbers', name: 'Retired Numbers', direction: 'higher' },
            { category: 'sports', stat: 'longest_winning_streak', name: 'Longest Win Streak', direction: 'higher' },
            { category: 'sports', stat: 'team_value', name: 'Team Value', direction: 'higher' },
            { category: 'sports', stat: 'average_home_attendance', name: 'Average Attendance', direction: 'higher' },
            { category: 'sports', stat: 'metro_population', name: 'Metro Population', direction: 'higher' },
            { category: 'sports', stat: 'franchise_name_changes', name: 'Name Changes', direction: 'higher' },
            { category: 'sports', stat: 'franchise_miles_moved', name: 'Miles Moved', direction: 'higher' },
            { category: 'sports', stat: 'average_ticket_price', name: 'Ticket Price', direction: 'higher' },
            { category: 'sports', stat: 'beer_price', name: 'Beer Price', direction: 'higher' },
            { category: 'sports', stat: 'parking_price', name: 'Parking Price', direction: 'higher' },
            { category: 'sports', stat: 'night_out_cost', name: 'Night Out Cost', direction: 'higher' },
            { category: 'sports', stat: 'draft_picks_first_overall', name: 'First Overall Picks', direction: 'higher' },
            { category: 'sports', stat: 'championship_drought', name: 'Championship Drought', direction: 'higher' },
            { category: 'sports', stat: 'city_championship_total', name: 'City Championships', direction: 'higher' },
            { category: 'sports', stat: 'championship_losses', name: 'Championship Losses', direction: 'higher' },

            // Companies (33 challenges)
            { category: 'companies', stat: 'market_cap', name: 'Market Cap', direction: 'higher' },
            { category: 'companies', stat: 'annual_revenue', name: 'Annual Revenue', direction: 'higher' },
            { category: 'companies', stat: 'employee_count', name: 'Employee Count', direction: 'higher' },
            { category: 'companies', stat: 'profit_margin', name: 'Profit Margin', direction: 'higher' },
            { category: 'companies', stat: 'rd_spending', name: 'R&D Spending', direction: 'higher' },
            { category: 'companies', stat: 'brand_value', name: 'Brand Value', direction: 'higher' },
            { category: 'companies', stat: 'customer_satisfaction', name: 'Customer Satisfaction', direction: 'higher' },
            { category: 'companies', stat: 'environmental_score', name: 'Environmental Score', direction: 'higher' },
            { category: 'companies', stat: 'global_offices', name: 'Global Offices', direction: 'higher' },
            { category: 'companies', stat: 'patents_held', name: 'Patents Held', direction: 'higher' },
            { category: 'companies', stat: 'ceo_approval', name: 'CEO Approval', direction: 'higher' },
            { category: 'companies', stat: 'diversity_index', name: 'Diversity Index', direction: 'higher' },
            { category: 'companies', stat: 'innovation_score', name: 'Innovation Score', direction: 'higher' },
            { category: 'companies', stat: 'social_impact', name: 'Social Impact', direction: 'higher' },
            { category: 'companies', stat: 'work_life_balance', name: 'Work-Life Balance', direction: 'higher' },
            { category: 'companies', stat: 'stock_performance', name: 'Stock Performance', direction: 'higher' },
            { category: 'companies', stat: 'advertising_spend', name: 'Advertising Spend', direction: 'higher' },
            { category: 'companies', stat: 'data_centers', name: 'Data Centers', direction: 'higher' },
            { category: 'companies', stat: 'charitable_giving', name: 'Charitable Giving', direction: 'higher' },
            { category: 'companies', stat: 'digital_transformation', name: 'Digital Transformation', direction: 'higher' },
            { category: 'companies', stat: 'revenue_growth', name: 'Revenue Growth', direction: 'higher' },
            { category: 'companies', stat: 'market_share', name: 'Market Share', direction: 'higher' },
            { category: 'companies', stat: 'employee_satisfaction', name: 'Employee Satisfaction', direction: 'higher' },
            { category: 'companies', stat: 'cybersecurity_score', name: 'Cybersecurity Score', direction: 'higher' },
            { category: 'companies', stat: 'supply_chain_efficiency', name: 'Supply Chain Efficiency', direction: 'higher' },
            { category: 'companies', stat: 'international_presence', name: 'International Presence', direction: 'higher' },
            { category: 'companies', stat: 'startup_acquisitions', name: 'Startup Acquisitions', direction: 'higher' },
            { category: 'companies', stat: 'cloud_infrastructure', name: 'Cloud Infrastructure', direction: 'higher' },
            { category: 'companies', stat: 'ai_investment', name: 'AI Investment', direction: 'higher' },
            { category: 'companies', stat: 'debt_to_equity', name: 'Debt-to-Equity', direction: 'lower' },
            { category: 'companies', stat: 'cash_reserves', name: 'Cash Reserves', direction: 'higher' },
            { category: 'companies', stat: 'sustainability_initiatives', name: 'Sustainability', direction: 'higher' },
            { category: 'companies', stat: 'regulatory_compliance', name: 'Regulatory Compliance', direction: 'higher' }
        ];

        // ===== HELPER FUNCTIONS =====

        // Get players as array (works for both local array and online object)
        function getPlayersArray() {
            if (GameModeManager.isLocal()) {
                return gameState.players; // Already an array
            } else {
                // Online mode: convert object to array using window.playerIds for correct order
                const playerIds = window.playerIds || Object.keys(gameState.players || {});
                return playerIds.map(id => gameState.players[id]);
            }
        }

        // Get player by index (works for both modes)
        function getPlayerByIndex(index) {
            if (GameModeManager.isLocal()) {
                return gameState.players[index];
            } else {
                const playerIds = window.playerIds || Object.keys(gameState.players || {});
                const playerId = playerIds[index];
                return gameState.players[playerId];
            }
        }

        // Get player count (works for both modes)
        function getPlayerCount() {
            if (GameModeManager.isLocal()) {
                return gameState.players?.length || 0;
            } else {
                return Object.keys(gameState.players || {}).length;
            }
        }

        // ===== INITIALIZATION =====
        function initializeGame() {
            // Check if external dataset loaded
            if (typeof MOVIES_TOKENS === 'undefined') {
                console.warn('⚠️ External dataset not loaded! Using fallback data.');
            } else {
                console.log('✅ External dataset loaded successfully!');
            }

            // Load all token pools from external dataset
            // Check if external data loaded, fallback to placeholder if not
            const moviesData = typeof MOVIES_TOKENS !== 'undefined' ? MOVIES_TOKENS : MOVIE_TOKENS_FALLBACK;
            const countriesData = typeof COUNTRIES_TOKENS !== 'undefined' ? COUNTRIES_TOKENS : COUNTRY_TOKENS_FALLBACK;
            const companiesData = typeof COMPANIES_TOKENS !== 'undefined' ? COMPANIES_TOKENS : [];
            const sportsData = typeof SPORTS_TOKENS !== 'undefined' ? SPORTS_TOKENS : [];

            gameState.categoryPools.movies = [...moviesData];
            gameState.categoryPools.countries = [...countriesData];
            gameState.categoryPools.companies = [...companiesData];
            gameState.categoryPools.sports = [...sportsData];

            console.log(`✅ Loaded ${gameState.categoryPools.movies.length} movies`);
            console.log(`✅ Loaded ${gameState.categoryPools.countries.length} countries`);
            console.log(`✅ Loaded ${gameState.categoryPools.companies.length} companies`);
            console.log(`✅ Loaded ${gameState.categoryPools.sports.length} sports teams`);

            // Set up player input fields
            updatePlayerInputs();

            // Check URL parameters for auto-mode selection
            const urlParams = new URLSearchParams(window.location.search);
            const modeParam = urlParams.get('mode');
            if (modeParam === 'online') {
                // Auto-select online mode when opened from button
                selectGameMode('online');
            }
        }

        function updatePlayerInputs() {
            const numPlayers = parseInt(document.getElementById('numPlayers').value);
            const container = document.getElementById('playerInputs');
            container.innerHTML = '';

            const defaultNames = ['Ben', 'Tabi', 'Daniel', 'Player 4', 'Player 5', 'Player 6'];

            for (let i = 0; i < numPlayers; i++) {
                const input = document.createElement('input');
                input.type = 'text';
                input.placeholder = `Player ${i + 1} Name`;
                input.id = `player${i}Name`;
                input.value = defaultNames[i] || `Player ${i + 1}`;
                container.appendChild(input);
            }
        }

        // ===== MODE SELECTION & ONLINE SETUP =====

        function selectGameMode(mode) {
            GameModeManager.setMode(mode);

            // Update mode indicator
            const indicator = document.getElementById('modeIndicator');
            const modeText = document.getElementById('modeText');

            if (mode === 'local') {
                indicator.style.background = '#667eea';
                modeText.textContent = '🏠 Local Game';
                indicator.style.display = 'block';
                // Show local setup screen
                showScreen('setupScreen');
            } else if (mode === 'online') {
                indicator.style.background = '#4caf50';
                modeText.textContent = '🌐 Online Game';
                indicator.style.display = 'block';
                // Initialize Firebase and show online setup
                initializeOnlineMode();
            }
        }

        async function initializeOnlineMode() {
            const success = await GameModeManager.initializeOnlineMode();

            if (success) {
                // Initialize room manager
                RoomManager.initialize(GameModeManager.database);
                showScreen('onlineSetupScreen');
            } else {
                alert('Failed to connect to Firebase. Please check your internet connection.');
                showScreen('modeSelectionScreen');
            }
        }

        function backToModeSelection() {
            showScreen('modeSelectionScreen');
        }

        async function createNewGame() {
            let playerName = document.getElementById('playerName').value.trim();

            // Default to "Player 1" if no name entered
            if (!playerName) {
                playerName = 'Player 1';
            }

            try {
                const roomCode = await RoomManager.createRoom(playerName);
                localStorage.setItem('currentRoomCode', roomCode);

                // Setup presence tracking
                RoomManager.setupPresence(roomCode);

                // Show lobby
                initializeLobby(roomCode, true);
            } catch (error) {
                console.error('Error creating room:', error);
                alert('Failed to create game: ' + error.message);
            }
        }

        async function joinExistingGame() {
            const roomCode = document.getElementById('roomCode').value.trim().toUpperCase();

            if (!roomCode || roomCode.length !== 6) {
                alert('Please enter a valid 6-character room code');
                return;
            }

            // Get player count in room to assign default name
            const database = GameModeManager.database;
            const playersSnapshot = await database.ref('games/' + roomCode + '/players').once('value');
            const players = playersSnapshot.val() || {};
            const playerCount = Object.keys(players).length;

            let playerName = document.getElementById('playerName').value.trim();
            if (!playerName) {
                playerName = `Player ${playerCount + 1}`;
            }

            try {
                await RoomManager.joinRoom(roomCode, playerName);
                localStorage.setItem('currentRoomCode', roomCode);

                // Setup presence tracking
                RoomManager.setupPresence(roomCode);

                // Show lobby
                initializeLobby(roomCode, false);
            } catch (error) {
                console.error('Error joining room:', error);
                alert('Failed to join game: ' + error.message);
            }
        }

        function copyRoomCode(code) {
            navigator.clipboard.writeText(code).then(() => {
                showNotification(`Room code ${code} copied to clipboard!`, 'success');
            }).catch(err => {
                console.error('Failed to copy:', err);
                showNotification('Failed to copy code', 'error');
            });
        }

        function initializeLobby(roomCode, isHost) {
            // Display room code with copy button
            const lobbyCodeEl = document.getElementById('lobbyRoomCode');
            lobbyCodeEl.innerHTML = `Room: <strong>${roomCode}</strong> <button onclick="copyRoomCode('${roomCode}')" style="margin-left: 10px; padding: 5px 10px; cursor: pointer;">📋 Copy</button>`;

            // Show/hide host controls
            const hostControls = document.getElementById('hostControls');
            const lobbyStatus = document.getElementById('lobbyStatus');

            if (isHost) {
                hostControls.style.display = 'block';
                lobbyStatus.style.display = 'none';
            } else {
                hostControls.style.display = 'none';
                lobbyStatus.style.display = 'block';
            }

            // Listen for player updates
            const database = GameModeManager.database;
            const playersRef = database.ref('games/' + roomCode + '/players');

            playersRef.on('value', (snapshot) => {
                const players = snapshot.val() || {};
                updateLobbyPlayersList(players);
            });

            // Listen for game start
            const gameStateRef = database.ref('games/' + roomCode + '/gameState');
            gameStateRef.on('value', (snapshot) => {
                const gameStateData = snapshot.val();
                console.log('📡 Lobby listener - phase:', gameStateData?.phase);
                if (gameStateData && (gameStateData.phase === 'challenge' || gameStateData.phase === 'playing' || gameStateData.phase === 'roundEnd')) {
                    // Game has started, transition to game screen
                    console.log('🚀 Game started! Setting up sync...');
                    syncGameStateFromFirebase();
                }
            });

            showScreen('lobbyScreen');
        }

        function updateLobbyPlayersList(players) {
            const listContainer = document.getElementById('lobbyPlayersList');
            listContainer.innerHTML = '';

            const playerIds = Object.keys(players);

            console.log('📋 Updating lobby with', playerIds.length, 'players:', playerIds);

            playerIds.forEach((playerId, index) => {
                const player = players[playerId];

                console.log('  Player', index + 1, ':', {
                    id: playerId,
                    name: player.name,
                    isHost: player.isHost,
                    connected: player.connected
                });

                const playerDiv = document.createElement('div');
                playerDiv.style.cssText = `
                    padding: 12px;
                    margin: 8px 0;
                    background: white;
                    border-radius: 8px;
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                `;

                const nameSpan = document.createElement('span');
                nameSpan.textContent = player.name || 'Unknown Player';
                nameSpan.style.fontWeight = 'bold';

                const rightDiv = document.createElement('div');
                rightDiv.style.display = 'flex';
                rightDiv.style.alignItems = 'center';
                rightDiv.style.gap = '10px';

                const statusSpan = document.createElement('span');
                if (player.isHost) {
                    statusSpan.textContent = '👑 Host';
                    statusSpan.style.color = '#764ba2';
                }

                const connectedIndicator = document.createElement('span');
                connectedIndicator.textContent = player.connected ? '🟢' : '🔴';

                rightDiv.appendChild(statusSpan);
                rightDiv.appendChild(connectedIndicator);

                playerDiv.appendChild(nameSpan);
                playerDiv.appendChild(rightDiv);

                listContainer.appendChild(playerDiv);
            });

            // Update start button state (only for host)
            const startGameBtn = document.getElementById('startGameBtn');
            const startGameHint = document.getElementById('startGameHint');

            if (startGameBtn) {
                console.log('🎮 Button state check: playerCount =', playerIds.length);
                if (playerIds.length >= 2) {
                    startGameBtn.disabled = false;
                    if (startGameHint) startGameHint.style.display = 'none';
                    console.log('✅ Button enabled');
                } else {
                    startGameBtn.disabled = true;
                    if (startGameHint) startGameHint.style.display = 'block';
                    console.log('❌ Button disabled');
                }
            }
        }

        async function startOnlineGame() {
            const roomCode = localStorage.getItem('currentRoomCode');
            const maxRounds = parseInt(document.getElementById('maxRounds').value);

            const database = GameModeManager.database;
            const gameRef = database.ref('games/' + roomCode);
            const gameStateRef = gameRef.child('gameState');
            const playersRef = gameRef.child('players');

            // Initialize player game data
            const playersSnapshot = await playersRef.once('value');
            const players = playersSnapshot.val() || {};

            for (const playerId in players) {
                await playersRef.child(playerId).update({
                    score: 0,
                    hand: [],
                    thisRound: [],
                    correctGuesses: 0,
                    wrongGuesses: 0
                });
            }

            // Update game state to start
            await gameStateRef.update({
                phase: 'challenge',
                round: 1,
                maxRounds: maxRounds,
                currentPlayer: 0,
                firstGuesser: 0,
                challengeMode: 'cards', // V4 uses card-based challenges
                playedChallenges: [],
                drawnChallengeCards: [],
                draftPool: [],
                centerToken: null,
                passedPlayers: [],
                selectedDraftToken: null,
                selectedCategory: null,
                previousCategory: null
            });

            console.log('✅ Game started with', maxRounds, 'rounds');
        }

        async function leaveLobby() {
            const roomCode = localStorage.getItem('currentRoomCode');

            if (roomCode) {
                await RoomManager.leaveRoom(roomCode);
                localStorage.removeItem('currentRoomCode');
            }

            showScreen('onlineSetupScreen');
        }

        let hasStartedGame = false;
        let lastSyncedRound = 0;

        function syncGameStateFromFirebase() {
            const roomCode = localStorage.getItem('currentRoomCode');
            const database = GameModeManager.database;

            // Listen to entire game state
            const gameRef = database.ref('games/' + roomCode);

            gameRef.on('value', (snapshot) => {
                const gameData = snapshot.val();
                if (gameData) {
                    // Convert Firebase structure to local gameState
                    const fbPlayers = gameData.players || {};
                    const fbGameState = gameData.gameState || {};

                    // Store player IDs for reference (order matters for currentPlayer index)
                    window.playerIds = Object.keys(fbPlayers);

                    // Keep players as object keyed by Firebase UID (NOT array)
                    gameState.players = fbPlayers;

                    // Copy game state fields (preserve categoryPools - they're not in Firebase)
                    const categoryPools = gameState.categoryPools; // Save pools

                    // Track changes for visual feedback
                    const oldCenterToken = gameState.centerToken?.name;
                    const oldCurrentPlayer = gameState.currentPlayer;

                    // Debug: Log what Firebase is sending
                    if (fbGameState.centerToken) {
                        console.log('📥 Firebase sync - centerToken:', fbGameState.centerToken?.name);
                        console.log('📥 Firebase sync - draftPool size:', fbGameState.draftPool?.length || Object.keys(fbGameState.draftPool || {}).length);
                    }

                    // V4.97.11: Exclude lockedOutPlayers from Object.assign (handled separately with timestamp check)
                    const { lockedOutPlayers: fbLockedOut, ...fbGameStateWithoutLockedOut } = fbGameState;
                    Object.assign(gameState, fbGameStateWithoutLockedOut);
                    gameState.categoryPools = categoryPools; // Restore pools
                    gameState.players = fbPlayers; // Restore players object (don't let fbGameState overwrite)

                    // V4.97.3: Explicitly handle fields that Firebase may have deleted (set to null)
                    // If these fields are missing from fbGameState, clear them locally
                    if (!fbGameState.hasOwnProperty('currentChallenge')) {
                        gameState.currentChallenge = null;
                    }
                    if (!fbGameState.hasOwnProperty('drawnChallengeCards')) {
                        gameState.drawnChallengeCards = null;
                    }

                    // Detect opponent actions and show detailed feedback
                    if (GameModeManager.isOnline() && fbGameState.lastAction) {
                        const action = fbGameState.lastAction;

                        // Only show if this is a recent action (within last 5 seconds)
                        if (Date.now() - action.timestamp < 5000) {
                            // Cash outs and passes should show for ALL players (not just opponents)
                            if (action.type === 'cash_out') {
                                showOpponentAction(
                                    `${action.playerName} cashed out ${action.tokenCount} tokens (${action.tag}) for ${action.points} points! 💰`,
                                    'success_green',
                                    8000  // Show for 8 seconds
                                );
                            } else if (action.type === 'pass') {
                                let message = `${action.playerName} passed. Tokens moved to hand (safe).`;
                                if (action.isFirstToPass) {
                                    message = `${action.playerName} passed FIRST. Will go first next round!`;
                                }
                                showOpponentAction(message, 'warning', 8000);
                            }
                            // Other actions only show for opponents
                            else if (!GameModeManager.isMyTurn()) {
                                if (action.type === 'correct_guess') {
                                    // Dark blue banner with green ball for higher, red ball for lower
                                    const ball = action.direction === 'higher' ? '🟢' : '🔴';
                                    const arrow = action.direction === 'higher' ? '⬆️' : '⬇️';
                                    showOpponentAction(
                                        `${ball} ${action.playerName} guessed ${arrow} ${action.direction.toUpperCase()} with "${action.draftedToken}" - CORRECT! +1 point`,
                                        'success_blue',
                                        8000  // Show for 8 seconds
                                    );
                                    // Highlight the drafted token briefly before it becomes center
                                    const draftedEl = Array.from(document.querySelectorAll('.draft-token')).find(
                                        el => el.textContent.includes(action.draftedToken)
                                    );
                                    if (draftedEl) {
                                        highlightToken(draftedEl.id || 'draftToken-' + action.timestamp);
                                    }
                                    setTimeout(() => highlightToken('centerToken'), 500);
                                } else if (action.type === 'wrong_guess') {
                                    const arrow = action.direction === 'higher' ? '⬆️' : '⬇️';
                                    const tokensMsg = action.tokensLost > 0 ? ` Lost ${action.tokensLost} token(s)!` : '';
                                    showOpponentAction(
                                        `${action.playerName} guessed ${arrow} ${action.direction.toUpperCase()} with "${action.draftedToken}" - WRONG!${tokensMsg} Player is OUT`,
                                        'error',
                                        8000  // Show for 8 seconds
                                    );
                                    highlightToken('centerToken');
                                }
                            }
                        }
                    }

                    // Update turn indicator (persistent, not a banner)
                    updateTurnIndicator();

                    // Convert Firebase objects back to arrays
                    if (gameState.draftPool && !Array.isArray(gameState.draftPool)) {
                        gameState.draftPool = Object.values(gameState.draftPool);
                    }
                    if (gameState.drawnChallengeCards && !Array.isArray(gameState.drawnChallengeCards)) {
                        gameState.drawnChallengeCards = Object.values(gameState.drawnChallengeCards);
                    }

                    // V4.96: Use explicit showModal flag from Firebase
                    const shouldShowModal = gameState.showModal === true;
                    const isCardsMode = gameState.challengeMode === 'cards';
                    const hasCards = gameState.drawnChallengeCards?.length > 0;
                    const modal = document.getElementById('categoryModal');
                    const isModalCurrentlyShown = modal?.classList.contains('active');

                    console.log('🔍 V4.96 Modal check:', {
                        showModalFlag: gameState.showModal,
                        shouldShowModal,
                        hasCards,
                        isCardsMode,
                        isModalCurrentlyShown,
                        currentChallenge: gameState.currentChallenge?.name || 'none'
                    });

                    // Show modal when Firebase showModal flag is true
                    if (shouldShowModal && isCardsMode && hasCards && !isModalCurrentlyShown) {
                        console.log('📥 showModal=true - showing modal for all players');
                        setTimeout(() => showCategorySelectionModal(), 100);
                    }

                    // Hide modal when Firebase showModal flag is false
                    if (gameState.showModal === false && isModalCurrentlyShown) {
                        console.log('🎯 showModal=false - closing modal for all players');
                        modal.classList.remove('active');
                    }

                    if (gameState.passedPlayers && !Array.isArray(gameState.passedPlayers)) {
                        gameState.passedPlayers = new Set(Object.values(gameState.passedPlayers));
                    } else if (Array.isArray(gameState.passedPlayers)) {
                        gameState.passedPlayers = new Set(gameState.passedPlayers);
                    } else if (!gameState.passedPlayers) {
                        gameState.passedPlayers = new Set();
                    }

                    // V4.97: Convert lockedOutPlayers from Firebase array to Set
                    console.log('🔍 DEBUG: lockedOutPlayers from Firebase:', fbGameState.lockedOutPlayers);
                    console.log('🔍 DEBUG: Firebase timestamp:', fbGameState.lockedOutPlayersTimestamp, 'Local timestamp:', window.lastLockedOutPlayersUpdate);

                    // V4.97.10: Only update if Firebase data is newer than our local update
                    // V4.97.19: Force number conversion to prevent string comparison issues
                    const fbTimestamp = Number(fbGameState.lockedOutPlayersTimestamp) || 0;
                    const localTimestamp = Number(window.lastLockedOutPlayersUpdate) || 0;

                    if (fbTimestamp >= localTimestamp) {
                        // Firebase has newer data, update from it
                        const fbLockedOut = fbGameState.lockedOutPlayers;
                        if (fbLockedOut && !Array.isArray(fbLockedOut)) {
                            gameState.lockedOutPlayers = new Set(Object.values(fbLockedOut));
                        } else if (Array.isArray(fbLockedOut)) {
                            gameState.lockedOutPlayers = new Set(fbLockedOut);
                        } else if (!fbLockedOut) {
                            gameState.lockedOutPlayers = new Set();
                        }
                        console.log('🔍 DEBUG: Updated lockedOutPlayers from Firebase:', Array.from(gameState.lockedOutPlayers));
                    } else {
                        // Local data is newer, keep it
                        console.log('🔍 DEBUG: Skipping stale Firebase update, keeping local:', Array.from(gameState.lockedOutPlayers));
                    }

                    // drawnChallengeCards should come from Firebase in online mode

                    console.log('🔄 Synced state:', {
                        phase: gameState.phase,
                        round: gameState.round,
                        currentPlayer: gameState.currentPlayer,
                        playerCount: getPlayerCount(),
                        hasStartedGame: hasStartedGame,
                        challengeMode: gameState.challengeMode,
                        gameEnding: gameState.gameEnding
                    });

                    // V4.97.24: If gameEnding flag is received from Firebase, show end screen after delay
                    if (fbGameState.gameEnding && !window.gameEndingTriggered) {
                        window.gameEndingTriggered = true;
                        gameState.gameEnding = true;
                        console.log('🏁 Received gameEnding flag from Firebase - showing end screen in 1.5s');
                        setTimeout(() => showGameEndScreen(), 1500);
                    }

                    // V4.97.8: Show broadcast notifications
                    if (fbGameState.lastNotification) {
                        const notification = fbGameState.lastNotification;
                        // Only show if we haven't seen this notification yet (check timestamp)
                        if (!window.lastNotificationTimestamp || notification.timestamp > window.lastNotificationTimestamp) {
                            window.lastNotificationTimestamp = notification.timestamp;
                            // Show notification locally (don't broadcast again to avoid loop)
                            showNotification(notification.message, notification.type, false);
                        }
                    }

                    // Update UI based on phase
                    if (gameState.phase === 'challenge' && !hasStartedGame) {
                        console.log('🎮 Starting game for first time!');
                        hasStartedGame = true;
                        // Show game screen and start round
                        showScreen('gameScreen');
                        console.log('📺 Showing game screen');
                        startNewRound();
                        console.log('🎲 Started new round');
                    } else if (hasStartedGame) {
                        // Continuous UI updates during gameplay
                        console.log('♻️ Continuous UI update');
                        updateGameUI();

                        // V4.88: Check if all players passed - if so, advance round (only first guesser does this)
                        if (gameState.allPassedFlag && !window.roundAdvancing) {
                            // Only the first guesser should call endRound() to prevent race conditions
                            const playerIds = window.playerIds || [];
                            const firstGuesserId = playerIds[gameState.firstGuesser];
                            const isFirstGuesser = firstGuesserId === window.currentUserId;

                            if (isFirstGuesser) {
                                console.log('🏁 All passed flag detected - advancing round (first guesser only)');
                                window.roundAdvancing = true;
                                setTimeout(() => {
                                    endRound();
                                    window.roundAdvancing = false;
                                }, 300);
                            } else {
                                console.log('🏁 All passed flag detected - waiting for first guesser to advance round');
                            }
                            return;
                        }

                        // V4.97: Handle challenge phase - first guesser draws cards, others wait
                        const modal = document.getElementById('categoryModal');
                        console.log(`🔍 V4.97 Phase/Mode check: phase=${gameState.phase}, mode=${gameState.challengeMode}`);

                        if (gameState.phase === 'challenge' && gameState.challengeMode === 'cards') {
                            // If no challenge selected and no cards drawn, first guesser should draw cards
                            console.log(`🔍 V4.97 Card check:`, {
                                currentChallenge: gameState.currentChallenge,
                                currentChallengeType: typeof gameState.currentChallenge,
                                currentChallengeIsNull: gameState.currentChallenge === null,
                                drawnCards: gameState.drawnChallengeCards,
                                drawnCardsLength: gameState.drawnChallengeCards?.length,
                                round: gameState.round
                            });

                            // V4.97: Check for null or empty array
                            const noCards = !gameState.drawnChallengeCards || gameState.drawnChallengeCards.length === 0;

                            if (!gameState.currentChallenge && noCards) {
                                // V4.97: Find my player index in the game
                                const playerIds = Object.keys(gameState.players || {});
                                const myPlayerIndex = playerIds.indexOf(window.currentUserId);
                                const isFirstGuesser = myPlayerIndex === gameState.firstGuesser;

                                console.log(`🔍 V4.97 Empty cards detected - myIndex=${myPlayerIndex}, firstGuesserIndex=${gameState.firstGuesser}, isFirstGuesser=${isFirstGuesser}, drawingCards=${window.drawingCards}`);

                                if (isFirstGuesser && !window.drawingCards) {
                                    console.log('🎴 V4.97 First guesser (index ${myPlayerIndex}) drawing new challenge cards for round', gameState.round);
                                    window.drawingCards = true;
                                    setTimeout(() => {
                                        startNewRound();
                                        window.drawingCards = false;
                                    }, 100);
                                }
                            }
                            // V4.92: Removed duplicate modal show logic that was triggering during gameplay
                            // Modal only shows via lines 1807-1811 when cards first arrive (using cardStateByRound tracking)
                            // This prevents modal from appearing mid-round when currentChallenge becomes null
                        }
                    } else {
                        console.log('⏸️ Waiting... phase:', gameState.phase, 'hasStarted:', hasStartedGame);
                    }
                }
            });
        }

        // Note: updateGameUI is defined later in the file (line ~2023)

        // ===== GAME FLOW =====
        function startGame() {
            const numPlayers = parseInt(document.getElementById('numPlayers').value);
            const firstPlayerIndex = parseInt(document.getElementById('firstPlayer').value);
            const maxRounds = parseInt(document.getElementById('numRounds').value);
            const challengeMode = document.getElementById('challengeMode').value;

            // Initialize players
            gameState.players = [];
            for (let i = 0; i < numPlayers; i++) {
                const nameInput = document.getElementById(`player${i}Name`);
                gameState.players.push({
                    name: nameInput.value || `Player ${i + 1}`,
                    score: 0,
                    hand: [],
                    thisRound: [],
                    correctGuesses: 0,
                    cashOuts: 0,
                    // V5.0: Bonus card properties
                    bonusCards: [],           // Cards in player's hand (hidden from others)
                    activeEffects: []         // Active card effects (multipliers, passive bonuses, etc.)
                });
            }

            gameState.currentPlayer = firstPlayerIndex;
            gameState.firstGuesser = firstPlayerIndex;
            gameState.round = 1;
            gameState.maxRounds = maxRounds;
            gameState.challengeMode = challengeMode;
            gameState.phase = 'challenge';

            // V5.0: Initialize bonus card system
            initializeBonusCards();

            // Switch to game screen
            showScreen('gameScreen');

            // Start first round
            startNewRound();
        }

        // ===== V5.0: BONUS CARD SYSTEM =====

        function shuffleArray(array) {
            // Fisher-Yates shuffle algorithm
            const shuffled = [...array];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }

        function initializeBonusCards() {
            // Shuffle the bonus card deck
            gameState.bonusCardDeck = shuffleArray([...BONUS_CARDS]);

            // Draw 3 cards for initial pool
            gameState.bonusCardPool = [
                gameState.bonusCardDeck.pop(),
                gameState.bonusCardDeck.pop(),
                gameState.bonusCardDeck.pop()
            ];

            gameState.bonusCardsInPlay = [];

            console.log('🎴 Bonus cards initialized:', {
                deck: gameState.bonusCardDeck.length,
                pool: gameState.bonusCardPool.map(c => c.name)
            });

            // Update UI to show card pool
            updateBonusCardPoolUI();
        }

        // V5.1.14: Get color for card based on ID prefix and number
        function getCardColor(cardId) {
            // Extract prefix (e.g., "INSTANT" from "INSTANT_3")
            const parts = cardId.split('_');
            const prefix = parts[0];
            const number = parts[1] ? parseInt(parts[1]) : 0;

            // Base colors for each prefix
            const baseColors = {
                'INSTANT': { h: 200, s: 70 },      // Blue family
                'DOUBLE': { h: 280, s: 70 },       // Purple family
                'TRIPLE': { h: 280, s: 70 },       // Purple family
                'STEAL': { h: 0, s: 70 },          // Red family
                'EXTRA': { h: 120, s: 70 },        // Green family
                'RETURN': { h: 40, s: 70 },        // Orange family
                'BLOCK': { h: 220, s: 70 },        // Blue-purple family
                'FORCE': { h: 340, s: 70 },        // Pink family
                'TOKEN': { h: 180, s: 70 },        // Cyan family
                'CASHOUT': { h: 300, s: 70 },      // Magenta family
                'CARD': { h: 260, s: 70 },         // Violet family
                'TAG': { h: 60, s: 70 },           // Yellow family
                'BONUS': { h: 160, s: 70 },        // Teal family
                'LUCKY': { h: 140, s: 70 },        // Lime family
                'SWAP': { h: 20, s: 70 }           // Red-orange family
            };

            const colorData = baseColors[prefix] || { h: 240, s: 50 };

            // Adjust lightness based on number (higher number = lighter shade)
            // Numbers typically range from 1-5
            const baseLightness = 45;
            const lightnessStep = 8; // Each number adds 8% lightness
            const lightness = baseLightness + (number * lightnessStep);

            return `hsl(${colorData.h}, ${colorData.s}%, ${lightness}%)`;
        }

        function updateBonusCardPoolUI() {
            const poolContainer = document.getElementById('bonusCardPool');
            if (!poolContainer) return;

            poolContainer.innerHTML = '';

            gameState.bonusCardPool.forEach((card, index) => {
                const cardDiv = document.createElement('div');
                cardDiv.className = 'bonus-card';

                cardDiv.innerHTML = `
                    <div class="card-header">${card.name}</div>
                    <div class="card-description">${card.description}</div>
                    <div class="card-type">${card.type}</div>
                `;
                poolContainer.appendChild(cardDiv);
            });
        }

        function showBonusCardPickModal() {
            const player = getPlayerByIndex(gameState.currentPlayer);
            const modal = document.getElementById('bonusCardPickModal');
            const content = document.getElementById('bonusCardPickContent');

            content.innerHTML = `
                <p style="margin-bottom: 20px; font-weight: bold; color: #764ba2;">
                    ${player.name}, choose 1 bonus card as reward for your cash-in!
                </p>
            `;

            gameState.bonusCardPool.forEach((card, index) => {
                const cardBtn = document.createElement('div');
                cardBtn.className = 'bonus-card-option';
                cardBtn.style.cssText = `
                    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                    color: white;
                    padding: 20px;
                    margin-bottom: 15px;
                    border-radius: 12px;
                    cursor: pointer;
                    transition: transform 0.2s, box-shadow 0.2s;
                `;
                cardBtn.innerHTML = `
                    <div style="font-size: 1.2em; font-weight: bold; margin-bottom: 8px;">${card.name}</div>
                    <div style="opacity: 0.9; margin-bottom: 10px;">${card.description}</div>
                    <div style="font-size: 0.85em; background: rgba(255,255,255,0.2); padding: 4px 10px; border-radius: 15px; display: inline-block;">
                        ${card.type.toUpperCase()}
                    </div>
                `;

                cardBtn.onmouseover = () => {
                    cardBtn.style.transform = 'translateY(-3px)';
                    cardBtn.style.boxShadow = '0 10px 25px rgba(0,0,0,0.3)';
                };
                cardBtn.onmouseout = () => {
                    cardBtn.style.transform = '';
                    cardBtn.style.boxShadow = '';
                };

                cardBtn.onclick = () => selectBonusCard(index);
                content.appendChild(cardBtn);
            });

            modal.classList.add('active');
        }

        function selectBonusCard(poolIndex) {
            const player = getPlayerByIndex(gameState.currentPlayer);
            const card = gameState.bonusCardPool[poolIndex];

            if (!card) {
                console.error('❌ Invalid card selection');
                return;
            }

            console.log(`🎴 ${player.name} selected bonus card:`, card.name);

            // V5.0.6: Check if player already has 4 cards (hand limit)
            if (player.bonusCards.length >= 4) {
                // Show discard UI - player must choose which card to discard
                showDiscardCardModal(player, card);
                return;
            }

            // Add card to player's hand
            player.bonusCards.push({...card});
            gameState.bonusCardsInPlay.push({...card, owner: player.name});

            // Apply immediate effects
            if (card.type === 'immediate') {
                applyCardEffect(player, card);
            }

            // Remove from pool
            gameState.bonusCardPool.splice(poolIndex, 1);

            // Replace card from deck (if deck has cards)
            if (gameState.bonusCardDeck.length > 0) {
                gameState.bonusCardPool.push(gameState.bonusCardDeck.pop());
            } else {
                console.log('⚠️ Bonus card deck is empty - no replacement');
            }

            // Update UI
            updateBonusCardPoolUI();
            renderPlayers(); // V5.0: Update player panels to show new card

            // Close modal
            document.getElementById('bonusCardPickModal').classList.remove('active');

            // Sync to Firebase if online
            if (GameModeManager.isOnline()) {
                syncBonusCardsToFirebase();
            }

            showNotification(`🎴 ${player.name} gained: ${card.name}!`, 'success');

            // V5.0: After card is picked, update UI and advance turn (complete cash-in flow)
            setTimeout(() => {
                updateGameUI();
                advanceTurn();
            }, 400);
        }

        // V5.0.6: CARD HAND LIMIT - Discard Modal
        function showDiscardCardModal(player, newCard) {
            const modal = document.getElementById('discardCardModal');
            const content = document.getElementById('discardCardContent');

            // Show current hand + new card
            const allCards = [...player.bonusCards, newCard];

            content.innerHTML = allCards.map((card, index) => {
                const isNew = index === player.bonusCards.length;
                return `
                    <div class="bonus-card-option" onclick="discardCardAndAddNew(${index}, ${isNew})" style="cursor: pointer; padding: 15px; margin: 10px 0; background: linear-gradient(135deg, ${isNew ? '#f59e0b 0%, #fbbf24' : '#667eea 0%, #764ba2'} 100%); color: white; border-radius: 8px; transition: transform 0.2s; position: relative;">
                        ${isNew ? '<div style="position: absolute; top: 5px; right: 10px; background: white; color: #f59e0b; padding: 2px 8px; border-radius: 4px; font-size: 0.8em; font-weight: bold;">NEW</div>' : ''}
                        <div style="font-size: 1.2em; font-weight: bold; margin-bottom: 5px;">${card.name}</div>
                        <div style="font-size: 0.9em; opacity: 0.9;">${card.description}</div>
                        <div style="margin-top: 8px; font-size: 0.85em; opacity: 0.8;">Click to ${isNew ? 'discard (don\'t take)' : 'discard'}</div>
                    </div>
                `;
            }).join('');

            // Store the poolIndex and card for later use
            modal.dataset.poolIndex = gameState.bonusCardPool.indexOf(newCard);
            modal.dataset.newCardId = newCard.id;

            modal.classList.add('active');
        }

        function discardCardAndAddNew(cardIndex, isNewCard) {
            const player = getPlayerByIndex(gameState.currentPlayer);
            const modal = document.getElementById('discardCardModal');
            const poolIndex = parseInt(modal.dataset.poolIndex);
            const newCard = gameState.bonusCardPool[poolIndex];

            if (isNewCard) {
                // Player chose to discard the new card (don't take it)
                console.log(`🗑️ ${player.name} discarded new card: ${newCard.name}`);
                showNotification(`Discarded ${newCard.name}`, 'success');
            } else {
                // Discard old card from hand
                const discardedCard = player.bonusCards.splice(cardIndex, 1)[0];
                console.log(`🗑️ ${player.name} discarded: ${discardedCard.name}`);

                // Add new card to hand
                player.bonusCards.push({...newCard});
                gameState.bonusCardsInPlay.push({...newCard, owner: player.name});

                // Apply immediate effects if new card is immediate
                if (newCard.type === 'immediate') {
                    applyCardEffect(player, newCard);
                }

                showNotification(`Discarded ${discardedCard.name}, gained ${newCard.name}!`, 'success');
            }

            // Remove card from pool
            gameState.bonusCardPool.splice(poolIndex, 1);

            // Replace card in pool from deck
            if (gameState.bonusCardDeck.length > 0) {
                gameState.bonusCardPool.push(gameState.bonusCardDeck.pop());
            }

            // Update UI
            updateBonusCardPoolUI();
            renderPlayers();

            // Close modals
            modal.classList.remove('active');
            document.getElementById('bonusCardPickModal').classList.remove('active');

            // Sync to Firebase if online
            if (GameModeManager.isOnline()) {
                syncBonusCardsToFirebase();
            }

            // Advance turn
            setTimeout(() => {
                updateGameUI();
                advanceTurn();
            }, 400);
        }

        function applyCardEffect(player, card) {
            switch(card.effect) {
                case 'points':
                    player.score += card.value;
                    console.log(`💰 ${player.name} gained ${card.value} points from ${card.name}`);
                    showNotification(`+${card.value} points!`, 'success');
                    break;

                case 'multiplier':
                    player.activeEffects.push({...card, usesRemaining: 1});
                    console.log(`✨ ${player.name} activated ${card.name} (${card.value}x multiplier)`);
                    break;

                case 'wildcard':
                    player.activeEffects.push({...card, usesRemaining: card.uses || 1});
                    console.log(`🌈 ${player.name} can use wildcard ${card.uses || 1} time(s)`);
                    break;

                default:
                    console.log(`🎴 ${player.name} received ${card.name} (${card.type})`);
            }
        }

        function syncBonusCardsToFirebase() {
            if (!GameModeManager.isOnline()) return;

            // Sync game state bonus cards
            GameModeManager.updateGameState({
                bonusCardDeck: gameState.bonusCardDeck.length, // Only send count for security
                bonusCardPool: gameState.bonusCardPool,
                bonusCardsInPlay: gameState.bonusCardsInPlay
            });

            // Sync each player's bonus cards (private to them)
            const playerIds = Object.keys(gameState.players);
            gameState.players.forEach((player, index) => {
                const playerId = playerIds[index];
                GameModeManager.updatePlayer(playerId, {
                    bonusCards: player.bonusCards,
                    activeEffects: player.activeEffects
                });
            });

            console.log('✅ Bonus cards synced to Firebase');
        }

        // V5.0.3: PLAY CARD MODAL FUNCTIONS
        function openPlayCardModal() {
            const player = getPlayerByIndex(gameState.currentPlayer);
            const modal = document.getElementById('playCardModal');
            const content = document.getElementById('playCardContent');

            // Filter for playable cards (not immediate, not endgame, not passive)
            const playableCards = player.bonusCards.filter(card =>
                card.type === 'playable' && !player.activeEffects.some(e => e.id === card.id)
            );

            if (playableCards.length === 0) {
                showNotification('No playable cards in hand', 'error');
                return;
            }

            content.innerHTML = playableCards.map((card, index) => `
                <div class="bonus-card-option" onclick="playCardFromHand(${index})" style="cursor: pointer; padding: 15px; margin: 10px 0; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border-radius: 8px; transition: transform 0.2s;">
                    <div style="font-size: 1.2em; font-weight: bold; margin-bottom: 5px;">${card.name}</div>
                    <div style="font-size: 0.9em; opacity: 0.9;">${card.description}</div>
                </div>
            `).join('');

            modal.classList.add('active');
        }

        function closePlayCardModal() {
            document.getElementById('playCardModal').classList.remove('active');
        }

        function playCardFromHand(cardIndex) {
            const player = getPlayerByIndex(gameState.currentPlayer);
            const playableCards = player.bonusCards.filter(card =>
                card.type === 'playable' && !player.activeEffects.some(e => e.id === card.id)
            );
            const card = playableCards[cardIndex];

            if (!card) {
                console.error('❌ Invalid card selection');
                return;
            }

            console.log(`🎴 ${player.name} is playing card:`, card.name);
            console.log(`🎴 Card effect:`, card.effect, `| Card data:`, card);

            // Handle different card effects
            switch(card.effect) {
                case 'steal':
                    executeStealToken(player, card);
                    break;

                case 'draw':
                    executeExtraDraw(player, card);
                    break;

                case 'swap':
                    executeSwapTokens(player, card);
                    break;

                case 'return_opponent':
                    executeReturnOpponentToken(player, card);
                    break;

                case 'multiplier':
                    // Add to active effects for next cash-in
                    player.activeEffects.push({...card, usesRemaining: 1});
                    showNotification(`✨ ${card.name} active! Next cash-in will be multiplied by ${card.value}x`, 'success');
                    removeCardFromHand(player, card);
                    break;

                case 'wildcard':
                    // Add to active effects for next cash-in
                    console.log(`🌈 Wildcard case hit! Card uses: ${card.uses}, usesRemaining will be: ${card.uses || 1}`);
                    player.activeEffects.push({...card, usesRemaining: card.uses || 1});
                    console.log(`🌈 Added to activeEffects. Total effects: ${player.activeEffects.length}`);
                    showNotification(`🌈 ${card.name} active! Can treat token as any tag`, 'success');
                    removeCardFromHand(player, card);
                    break;

                case 'block':
                    executeBlockCashout(player, card);
                    break;

                case 'discard':
                    executeForceDiscard(player, card);
                    break;

                default:
                    showNotification(`Card effect '${card.effect}' not yet implemented`, 'error');
                    return;
            }

            closePlayCardModal();
            renderPlayers();
            updateActionButtons();

            // Sync to Firebase if online
            if (GameModeManager.isOnline()) {
                syncBonusCardsToFirebase();
            }
        }

        function removeCardFromHand(player, card) {
            const cardIndexInHand = player.bonusCards.findIndex(c => c.id === card.id);
            if (cardIndexInHand > -1) {
                player.bonusCards.splice(cardIndexInHand, 1);
                console.log(`🗑️ Removed ${card.name} from ${player.name}'s hand`);
            }
        }

        // ===== V5.1.0: TOKEN SELECTION MODAL =====
        let tokenSelectionCallback = null;

        // V5.1.14: PLAYER SELECTION MODAL
        let playerSelectionCallback = null;

        function showPlayerSelectionModal(players, title, instructions, callback) {
            const modal = document.getElementById('tokenSelectionModal'); // Reuse token modal
            const titleEl = document.getElementById('tokenSelectionTitle');
            const instructionsEl = document.getElementById('tokenSelectionInstructions');
            const content = document.getElementById('tokenSelectionContent');

            titleEl.textContent = title;
            instructionsEl.textContent = instructions;

            // Display players as clickable items
            content.innerHTML = players.map((player, index) => {
                const hand = Array.isArray(player.hand) ? player.hand : Object.values(player.hand || {});
                const thisRound = Array.isArray(player.thisRound) ? player.thisRound : Object.values(player.thisRound || {});
                const tokenCount = hand.length + thisRound.length;

                return `
                    <div data-player-index="${index}" class="player-selection-item" style="cursor: pointer; display: flex; flex-direction: column; align-items: center; gap: 5px; padding: 15px; border-radius: 8px; background: linear-gradient(135deg, #f59e0b 0%, #f97316 100%); color: white; transition: transform 0.2s;">
                        <div style="font-size: 1.2em; font-weight: bold;">${player.name}</div>
                        <div style="font-size: 0.9em; opacity: 0.9;">${tokenCount} token${tokenCount !== 1 ? 's' : ''}</div>
                    </div>
                `;
            }).join('');

            // Add click event listeners
            content.querySelectorAll('.player-selection-item').forEach(item => {
                item.addEventListener('click', function() {
                    const playerIndex = parseInt(this.dataset.playerIndex);
                    selectPlayer(players[playerIndex]);
                });
            });

            playerSelectionCallback = callback;
            modal.classList.add('active');
        }

        function selectPlayer(player) {
            const modal = document.getElementById('tokenSelectionModal');
            modal.classList.remove('active');

            const callback = playerSelectionCallback;
            playerSelectionCallback = null;

            if (callback) {
                callback(player);
            }
        }

        function showTokenSelectionModal(tokens, title, instructions, callback) {
            const modal = document.getElementById('tokenSelectionModal');
            const titleEl = document.getElementById('tokenSelectionTitle');
            const instructionsEl = document.getElementById('tokenSelectionInstructions');
            const content = document.getElementById('tokenSelectionContent');

            titleEl.textContent = title;
            instructionsEl.textContent = instructions;

            // Display tokens as clickable circles
            content.innerHTML = tokens.map((token, index) => `
                <div data-token-index="${index}" class="token-selection-item" style="cursor: pointer; display: flex; flex-direction: column; align-items: center; gap: 5px; padding: 10px; border-radius: 8px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; transition: transform 0.2s;">
                    <div style="width: 60px; height: 60px; border-radius: 50%; background: rgba(255,255,255,0.2); display: flex; align-items: center; justify-content: center; font-weight: bold; border: 3px solid white; font-size: 0.9em;">${token.id || token.name.substring(0, 3).toUpperCase()}</div>
                    <div style="font-size: 0.8em; text-align: center; word-wrap: break-word; max-width: 100px;">${token.name}</div>
                </div>
            `).join('');

            // Add click event listeners to each token
            content.querySelectorAll('.token-selection-item').forEach(item => {
                item.addEventListener('click', function() {
                    const tokenIndex = parseInt(this.dataset.tokenIndex);
                    selectToken(tokenIndex);
                });
            });

            tokenSelectionCallback = callback;
            modal.classList.add('active');
        }

        function selectToken(tokenIndex) {
            // V5.1.7: Close modal and clear callback BEFORE executing to prevent double-clicks
            const modal = document.getElementById('tokenSelectionModal');
            modal.classList.remove('active');

            const callback = tokenSelectionCallback;
            tokenSelectionCallback = null;

            if (callback) {
                callback(tokenIndex);
            }
        }

        function closeTokenSelectionModal() {
            const modal = document.getElementById('tokenSelectionModal');
            modal.classList.remove('active');
            tokenSelectionCallback = null;
        }

        // V5.1.0: TOKEN MANIPULATION CARD EFFECTS (now with player choice)
        function executeStealToken(player, card) {
            console.log(`🎯 Snatch: Starting for ${player.name}`);
            console.log(`🎯 Draft pool length:`, gameState.draftPool.length);
            console.log(`🎯 Player thisRound before:`, player.thisRound);

            if (gameState.draftPool.length === 0) {
                showNotification('No tokens in draft pool to steal!', 'error');
                return;
            }

            // V5.1.0: Show selection modal for player to choose
            showTokenSelectionModal(
                gameState.draftPool,
                '🎯 Snatch - Choose Token',
                'Select a token to steal from the draft pool:',
                (tokenIndex) => {
                    console.log(`🎯 Snatch: Selected index ${tokenIndex}`);
                    const stolenToken = gameState.draftPool.splice(tokenIndex, 1)[0];
                    console.log(`🎯 Stolen token:`, stolenToken);

                    if (!Array.isArray(player.thisRound)) {
                        player.thisRound = Object.values(player.thisRound || {});
                    }
                    player.thisRound.push(stolenToken);
                    console.log(`🎯 Player thisRound after:`, player.thisRound);

                    showNotification(`🎯 ${player.name} stole ${stolenToken.name}!`, 'success');

                    removeCardFromHand(player, card);
                    renderDraftPool();
                    updateGameUI();
                }
            );
        }

        function executeExtraDraw(player, card) {
            const drawCount = card.value || 2;
            console.log(`🎴 Double Pick: Starting for ${player.name}, drawing ${drawCount} tokens`);
            console.log(`🎴 Draft pool length:`, gameState.draftPool.length);
            console.log(`🎴 Player thisRound before:`, player.thisRound);

            if (gameState.draftPool.length === 0) {
                showNotification('No tokens in draft pool to draw!', 'error');
                return;
            }

            // V5.1.0: Multi-select tokens (select first token, then second)
            const drawnTokens = [];
            let remainingDraws = Math.min(drawCount, gameState.draftPool.length);

            function drawNextToken() {
                if (remainingDraws === 0) {
                    console.log(`🎴 Double Pick: Complete! Drew ${drawnTokens.length} tokens:`, drawnTokens);
                    console.log(`🎴 Player thisRound after:`, player.thisRound);
                    showNotification(`🎴 ${player.name} drew ${drawnTokens.length} tokens: ${drawnTokens.map(t => t.name).join(', ')}!`, 'success');

                    removeCardFromHand(player, card);
                    renderDraftPool();
                    updateGameUI();
                    return;
                }

                console.log(`🎴 Double Pick: Showing modal for token ${drawnTokens.length + 1}/${drawCount}`);
                showTokenSelectionModal(
                    gameState.draftPool,
                    `🎴 Double Pick - Choose Token (${drawnTokens.length + 1}/${drawCount})`,
                    `Select token ${drawnTokens.length + 1} of ${drawCount}:`,
                    (tokenIndex) => {
                        console.log(`🎴 Double Pick: Selected index ${tokenIndex}`);
                        const token = gameState.draftPool.splice(tokenIndex, 1)[0];
                        console.log(`🎴 Drew token:`, token);

                        if (!Array.isArray(player.thisRound)) {
                            player.thisRound = Object.values(player.thisRound || {});
                        }
                        player.thisRound.push(token);
                        drawnTokens.push(token);
                        remainingDraws--;
                        console.log(`🎴 Remaining draws: ${remainingDraws}`);
                        drawNextToken();
                    }
                );
            }

            drawNextToken();
        }

        function executeSwapTokens(player, card) {
            // V5.1.0: Ensure arrays (hand/thisRound might be objects in 4forMore)
            const hand = Array.isArray(player.hand) ? player.hand : Object.values(player.hand || {});
            const thisRound = Array.isArray(player.thisRound) ? player.thisRound : Object.values(player.thisRound || {});
            const playerTokens = [...hand, ...thisRound];

            if (playerTokens.length === 0) {
                showNotification('No tokens in your hand to swap!', 'error');
                return;
            }

            if (gameState.draftPool.length === 0) {
                showNotification('No tokens in draft pool to swap with!', 'error');
                return;
            }

            // V5.1.0: Two-step selection - first player's token, then pool token
            showTokenSelectionModal(
                playerTokens,
                '🔄 Trade - Choose Your Token',
                'Select a token from your hand to trade away:',
                (playerTokenIndex) => {
                    const playerToken = playerTokens[playerTokenIndex];

                    // V5.1.13: Filter pool to only show same category tokens
                    const sameCategory = gameState.draftPool.filter(t => t.category === playerToken.category);

                    if (sameCategory.length === 0) {
                        showNotification(`No ${playerToken.category} tokens in draft pool to swap with!`, 'warning');
                        return;
                    }

                    // Now select pool token (same category only)
                    showTokenSelectionModal(
                        sameCategory,
                        '🔄 Trade - Choose Pool Token',
                        `Trading away ${playerToken.name} (${playerToken.category}). Select ${playerToken.category} token from pool:`,
                        (filteredIndex) => {
                            const poolToken = sameCategory[filteredIndex];
                            const poolTokenIndex = gameState.draftPool.findIndex(t => t.id === poolToken.id);

                            console.log(`🔄 Trade: Player selected token ${playerToken.name}, pool token ${poolToken.name}`);
                            console.log(`🔄 Player hand before:`, player.hand);
                            console.log(`🔄 Player thisRound before:`, player.thisRound);

                            // Ensure hand and thisRound are arrays before using array methods
                            if (!Array.isArray(player.hand)) {
                                player.hand = Object.values(player.hand || {});
                            }
                            if (!Array.isArray(player.thisRound)) {
                                player.thisRound = Object.values(player.thisRound || {});
                            }

                            // Remove from player's hand/thisRound
                            const handIndex = player.hand.findIndex(t => t && t.id === playerToken.id);
                            const thisRoundIndex = player.thisRound.findIndex(t => t && t.id === playerToken.id);

                            console.log(`🔄 Found in hand at index: ${handIndex}, in thisRound at index: ${thisRoundIndex}`);

                            if (handIndex > -1) {
                                player.hand.splice(handIndex, 1);
                                console.log(`🔄 Removed from hand`);
                            } else if (thisRoundIndex > -1) {
                                player.thisRound.splice(thisRoundIndex, 1);
                                console.log(`🔄 Removed from thisRound`);
                            } else {
                                console.error(`🔄 ERROR: Could not find token ${playerToken.name} in player's hand or thisRound!`);
                            }

                            // Add pool token to player's thisRound
                            player.thisRound.push(poolToken);
                            console.log(`🔄 Added ${poolToken.name} to player's thisRound`);

                            // Replace pool token with player's token
                            gameState.draftPool[poolTokenIndex] = playerToken;
                            console.log(`🔄 Put ${playerToken.name} into draft pool at index ${poolTokenIndex}`);

                            console.log(`🔄 Player hand after:`, player.hand);
                            console.log(`🔄 Player thisRound after:`, player.thisRound);

                            showNotification(`🔄 Swapped ${playerToken.name} for ${poolToken.name}!`, 'success');

                            removeCardFromHand(player, card);
                            renderDraftPool();
                            updateGameUI();
                        }
                    );
                }
            );
        }

        function executeReturnToken(player, card) {
            console.log(`♻️ Recycle: Starting for ${player.name}`);
            // V5.1.0: Ensure arrays (hand/thisRound might be objects in 4forMore)
            const hand = Array.isArray(player.hand) ? player.hand : Object.values(player.hand || {});
            const thisRound = Array.isArray(player.thisRound) ? player.thisRound : Object.values(player.thisRound || {});
            const playerTokens = [...hand, ...thisRound];

            console.log(`♻️ Player hand:`, player.hand);
            console.log(`♻️ Player thisRound:`, player.thisRound);
            console.log(`♻️ Combined playerTokens:`, playerTokens);

            if (playerTokens.length === 0) {
                showNotification('No tokens to return!', 'error');
                return;
            }

            // V5.1.0: Show selection modal for player to choose which token to return
            showTokenSelectionModal(
                playerTokens,
                '♻️ Recycle - Choose Token',
                'Select a token from your hand to return to pool:',
                (tokenIndex) => {
                    console.log(`♻️ Recycle: Selected index ${tokenIndex}`);
                    const returnedToken = playerTokens[tokenIndex];
                    console.log(`♻️ Returning token:`, returnedToken);

                    // Ensure hand and thisRound are arrays before using array methods
                    if (!Array.isArray(player.hand)) {
                        player.hand = Object.values(player.hand || {});
                    }
                    if (!Array.isArray(player.thisRound)) {
                        player.thisRound = Object.values(player.thisRound || {});
                    }

                    // Remove from player's hand/thisRound
                    const handIndex = player.hand.findIndex(t => t && t.id === returnedToken.id);
                    const thisRoundIndex = player.thisRound.findIndex(t => t && t.id === returnedToken.id);

                    console.log(`♻️ Found in hand at index: ${handIndex}, in thisRound at index: ${thisRoundIndex}`);

                    if (handIndex > -1) {
                        player.hand.splice(handIndex, 1);
                        console.log(`♻️ Removed from hand`);
                    } else if (thisRoundIndex > -1) {
                        player.thisRound.splice(thisRoundIndex, 1);
                        console.log(`♻️ Removed from thisRound`);
                    } else {
                        console.error(`♻️ ERROR: Could not find token in hand or thisRound!`);
                    }

                    // Return to draft pool
                    gameState.draftPool.push(returnedToken);
                    console.log(`♻️ Added to draft pool. Draft pool now has ${gameState.draftPool.length} tokens`);

                    showNotification(`♻️ ${player.name} returned ${returnedToken.name} to pool`, 'success');

                    removeCardFromHand(player, card);
                    renderDraftPool();
                    updateGameUI();
                }
            );
        }

        // V5.1.14: OPPONENT TOKEN RETURN
        function executeReturnOpponentToken(player, card) {
            console.log(`♻️ Saboteur: ${player.name} targeting opponent tokens`);

            // Get all opponents with tokens
            const opponents = gameState.players.filter((p, idx) => {
                if (idx === gameState.currentPlayer) return false;
                const hand = Array.isArray(p.hand) ? p.hand : Object.values(p.hand || {});
                const thisRound = Array.isArray(p.thisRound) ? p.thisRound : Object.values(p.thisRound || {});
                return (hand.length + thisRound.length) > 0;
            });

            if (opponents.length === 0) {
                showNotification('No opponents have tokens!', 'warning');
                return;
            }

            // Step 1: Select opponent
            showPlayerSelectionModal(
                opponents,
                '♻️ Saboteur - Choose Opponent',
                'Select which opponent to target:',
                (targetPlayer) => {
                    console.log(`♻️ Target selected: ${targetPlayer.name}`);

                    // Get target's tokens
                    const hand = Array.isArray(targetPlayer.hand) ? targetPlayer.hand : Object.values(targetPlayer.hand || {});
                    const thisRound = Array.isArray(targetPlayer.thisRound) ? targetPlayer.thisRound : Object.values(targetPlayer.thisRound || {});
                    const targetTokens = [...hand, ...thisRound];

                    // Step 2: Select which token to return
                    showTokenSelectionModal(
                        targetTokens,
                        '♻️ Saboteur - Choose Token',
                        `Select a token from ${targetPlayer.name}'s hand to return to pool:`,
                        (tokenIndex) => {
                            const returnedToken = targetTokens[tokenIndex];
                            console.log(`♻️ Returning ${returnedToken.name} from ${targetPlayer.name}`);

                            // Ensure arrays
                            if (!Array.isArray(targetPlayer.hand)) {
                                targetPlayer.hand = Object.values(targetPlayer.hand || {});
                            }
                            if (!Array.isArray(targetPlayer.thisRound)) {
                                targetPlayer.thisRound = Object.values(targetPlayer.thisRound || {});
                            }

                            // Remove from target's hand/thisRound
                            const handIndex = targetPlayer.hand.findIndex(t => t && t.id === returnedToken.id);
                            const thisRoundIndex = targetPlayer.thisRound.findIndex(t => t && t.id === returnedToken.id);

                            if (handIndex > -1) {
                                targetPlayer.hand.splice(handIndex, 1);
                            } else if (thisRoundIndex > -1) {
                                targetPlayer.thisRound.splice(thisRoundIndex, 1);
                            }

                            // Return to draft pool
                            gameState.draftPool.push(returnedToken);

                            showNotification(`♻️ ${player.name} forced ${targetPlayer.name} to return ${returnedToken.name}!`, 'success');

                            removeCardFromHand(player, card);
                            renderDraftPool();
                            renderPlayers();
                            updateGameUI();
                        }
                    );
                }
            );
        }

        // V5.0.6: DEFENSIVE CARD EFFECTS
        function executeBlockCashout(player, card) {
            // Add block effect to active effects - will be checked when ANY player tries to cash out
            player.activeEffects.push({...card, usesRemaining: 1, targetNextCashout: true});

            showNotification(`🛡️ ${player.name} activated Veto! Next cash-in will be blocked!`, 'success');
            console.log(`🛡️ ${player.name} activated block card - next cash-in will be blocked`);

            removeCardFromHand(player, card);
        }

        function executeForceDiscard(player, card) {
            console.log(`💣 Sabotage: Starting for ${player.name}`);

            // Get all other players with tokens
            const eligibleTargets = gameState.players.filter((p, idx) => {
                const hand = Array.isArray(p.hand) ? p.hand : Object.values(p.hand || {});
                const thisRound = Array.isArray(p.thisRound) ? p.thisRound : Object.values(p.thisRound || {});
                const tokens = [...hand, ...thisRound];
                return idx !== gameState.currentPlayer && tokens.length > 0;
            });

            console.log(`💣 Eligible targets:`, eligibleTargets.map(p => p.name));

            if (eligibleTargets.length === 0) {
                showNotification('No opponents with tokens to target!', 'error');
                return;
            }

            // V5.1.6: Show player selection modal
            const playerOptions = eligibleTargets.map((p, idx) => {
                const hand = Array.isArray(p.hand) ? p.hand : Object.values(p.hand || {});
                const thisRound = Array.isArray(p.thisRound) ? p.thisRound : Object.values(p.thisRound || {});
                const tokenCount = hand.length + thisRound.length;
                return {
                    name: `${p.name} (${tokenCount} tokens)`,
                    player: p,
                    originalIndex: gameState.players.indexOf(p)
                };
            });

            // Create mock tokens for player selection (using player names as tokens)
            const playerTokens = playerOptions.map((opt, idx) => ({
                id: `player_${idx}`,
                name: opt.name,
                player: opt.player,
                originalIndex: opt.originalIndex
            }));

            console.log(`💣 Showing player selection modal`);
            showTokenSelectionModal(
                playerTokens,
                '💣 Sabotage - Choose Target',
                'Select a player to sabotage:',
                (playerIndex) => {
                    const targetPlayer = playerOptions[playerIndex].player;
                    console.log(`💣 Selected target: ${targetPlayer.name}`);

                    // Ensure arrays
                    const hand = Array.isArray(targetPlayer.hand) ? targetPlayer.hand : Object.values(targetPlayer.hand || {});
                    const thisRound = Array.isArray(targetPlayer.thisRound) ? targetPlayer.thisRound : Object.values(targetPlayer.thisRound || {});
                    const targetTokens = [...hand, ...thisRound];

                    console.log(`💣 Target has ${targetTokens.length} tokens:`, targetTokens);

                    const discardCount = Math.min(2, targetTokens.length);
                    const discardedTokens = [];

                    // V5.1.6: Let target choose which tokens to discard
                    function chooseNextDiscard() {
                        if (discardedTokens.length >= discardCount) {
                            console.log(`💣 Sabotage complete! ${targetPlayer.name} discarded:`, discardedTokens);
                            showNotification(`💣 ${player.name} sabotaged ${targetPlayer.name}! Discarded ${discardCount} token(s)`, 'success');
                            removeCardFromHand(player, card);
                            updateGameUI();
                            return;
                        }

                        // Get current tokens (after previous discards)
                        const currentHand = Array.isArray(targetPlayer.hand) ? targetPlayer.hand : Object.values(targetPlayer.hand || {});
                        const currentThisRound = Array.isArray(targetPlayer.thisRound) ? targetPlayer.thisRound : Object.values(targetPlayer.thisRound || {});
                        const currentTokens = [...currentHand, ...currentThisRound];

                        console.log(`💣 ${targetPlayer.name} choosing discard ${discardedTokens.length + 1}/${discardCount}`);
                        showTokenSelectionModal(
                            currentTokens,
                            `💣 ${targetPlayer.name} - Discard Token (${discardedTokens.length + 1}/${discardCount})`,
                            `${player.name} sabotaged you! Choose token ${discardedTokens.length + 1} to discard:`,
                            (tokenIndex) => {
                                const discardedToken = currentTokens[tokenIndex];
                                console.log(`💣 ${targetPlayer.name} discarding:`, discardedToken);

                                // Ensure arrays before removal
                                if (!Array.isArray(targetPlayer.hand)) {
                                    targetPlayer.hand = Object.values(targetPlayer.hand || {});
                                }
                                if (!Array.isArray(targetPlayer.thisRound)) {
                                    targetPlayer.thisRound = Object.values(targetPlayer.thisRound || {});
                                }

                                // Remove from player's hand or thisRound
                                const handIndex = targetPlayer.hand.findIndex(t => t && t.id === discardedToken.id);
                                const thisRoundIndex = targetPlayer.thisRound.findIndex(t => t && t.id === discardedToken.id);

                                if (handIndex > -1) {
                                    targetPlayer.hand.splice(handIndex, 1);
                                    console.log(`💣 Removed from hand`);
                                } else if (thisRoundIndex > -1) {
                                    targetPlayer.thisRound.splice(thisRoundIndex, 1);
                                    console.log(`💣 Removed from thisRound`);
                                }

                                discardedTokens.push(discardedToken);
                                chooseNextDiscard();
                            }
                        );
                    }

                    chooseNextDiscard();
                }
            );
        }

        function startNewRound() {
            console.log(`🎲 startNewRound() called - firstGuesser index: ${gameState.firstGuesser}`);

            // V4.97.15: Removed closeLockedOutModal() - no longer using popup modal system
            // Using lockedOutOverlay managed by updateLockedOutState() instead

            // Reset current player to first guesser for the new round
            gameState.currentPlayer = gameState.firstGuesser;
            console.log(`🔄 Reset currentPlayer to firstGuesser: ${gameState.currentPlayer}`);

            // Open category selection modal for first guesser
            const firstGuesserName = getPlayerByIndex(gameState.firstGuesser)?.name || 'Player';
            const firstGuesserElem = document.getElementById('firstGuesserName');
            if (firstGuesserElem) {
                firstGuesserElem.textContent = firstGuesserName;
            }

            // In online mode, only the first guesser draws cards (others receive via sync)
            // Use window.playerIds which has actual Firebase user IDs, not gameState.players indices
            const playerIds = window.playerIds || Object.keys(gameState.players || {});
            const firstGuesserId = playerIds[gameState.firstGuesser];
            const isFirstGuesser = GameModeManager.isLocal() || (firstGuesserId === window.currentUserId);

            console.log(`👤 This player: ${window.currentUserId}, First guesser: ${firstGuesserId}, isFirstGuesser: ${isFirstGuesser}`);

            // If in 'cards' mode, manage challenge cards
            if (gameState.challengeMode === 'cards' && isFirstGuesser) {
                const categories = ['movies', 'countries', 'companies', 'sports'];

                // V4.88: First round OR no previous category: draw all cards fresh
                // Use previousCategory instead of selectedCategory (which is cleared by endRound)
                // V4.97.4: Check if drawnChallengeCards is null or empty
                if (gameState.round === 1 || !gameState.previousCategory || !gameState.drawnChallengeCards || gameState.drawnChallengeCards.length === 0) {
                    console.log(`🎴 Drawing fresh challenge cards (round ${gameState.round}, prevCat: ${gameState.previousCategory})`);
                    gameState.drawnChallengeCards = [];
                    categories.forEach(category => {
                        // Filter out challenges that have been played
                        const categoryChallenges = CHALLENGES.filter(c =>
                            c.category === category &&
                            !gameState.playedChallenges.some(played => played.name === c.name && played.category === c.category)
                        );
                        const randomIndex = Math.floor(Math.random() * categoryChallenges.length);
                        gameState.drawnChallengeCards.push({
                            challenge: categoryChallenges[randomIndex],
                            roundsAvailable: 1
                        });
                    });
                } else {
                    // V4.88: Subsequent rounds: replace the previously selected category's card
                    // Use previousCategory (persists) instead of selectedCategory (cleared by endRound)
                    const previousCategory = gameState.previousCategory;
                    console.log(`🔄 Replacing challenge card for category: ${previousCategory}`);

                    gameState.drawnChallengeCards = gameState.drawnChallengeCards.map(cardData => {
                        if (cardData.challenge.category === previousCategory) {
                            // Replace this card with a new one from the same category, excluding played challenges
                            const categoryChallenges = CHALLENGES.filter(c =>
                                c.category === previousCategory &&
                                !gameState.playedChallenges.some(played => played.name === c.name && played.category === c.category)
                            );

                            if (categoryChallenges.length === 0) {
                                // No more challenges available in this category
                                showNotification(`No more ${previousCategory} challenges available!`, 'warning');
                                return cardData; // Keep the old card
                            }

                            const randomIndex = Math.floor(Math.random() * categoryChallenges.length);
                            const newChallenge = categoryChallenges[randomIndex];
                            console.log(`  ✅ Replaced ${previousCategory} card: "${cardData.challenge.name}" → "${newChallenge.name}"`);
                            return {
                                challenge: newChallenge,
                                roundsAvailable: 1
                            };
                        } else {
                            // Keep this card, increment rounds available
                            console.log(`  ⏩ Keeping ${cardData.challenge.category} card: "${cardData.challenge.name}" (round ${cardData.roundsAvailable + 1})`);
                            return {
                                challenge: cardData.challenge,
                                roundsAvailable: cardData.roundsAvailable + 1
                            };
                        }
                    });
                }
            }

            // Reset selections (only needed for manual mode, but safe to try)
            const categorySelect = document.getElementById('categorySelect');
            const challengeSelect = document.getElementById('challengeSelect');
            const categoryWarning = document.getElementById('categoryWarning');

            if (categorySelect) categorySelect.value = '';
            if (challengeSelect) challengeSelect.innerHTML = '<option value="">-- Select Challenge --</option>';
            if (categoryWarning) categoryWarning.style.display = 'none';

            // Sync drawn challenge cards to Firebase if online mode (only if first guesser)
            // NOTE: currentPlayer is already set by endRound(), don't overwrite it here
            if (GameModeManager.isOnline() && isFirstGuesser) {
                GameModeManager.updateGameState({
                    drawnChallengeCards: gameState.drawnChallengeCards,
                    showModal: true  // V4.96: Explicit flag to show modal for all players
                }).then(() => {
                    console.log('✅ Synced challenge cards + showModal=true to Firebase');
                }).catch(err => {
                    console.error('❌ Failed to sync:', err);
                });
            }

            // Show modal for all players (they can all see the options, but only first guesser can select)
            if (gameState.challengeMode === 'cards') {
                showCategorySelectionModal();
            }

            // V4.97.13: Force update lockout state after new round starts
            // This ensures lockout overlay is hidden now that lockedOutPlayers is cleared
            updateLockedOutState();
        }

        function showCategorySelectionModal() {
            console.log('🎴 showCategorySelectionModal() called');
            const modal = document.getElementById('categoryModal');
            const modalContent = modal.querySelector('.modal-content');

            if (gameState.challengeMode === 'cards') {
                // Safety check: wait for cards to be populated
                if (!gameState.drawnChallengeCards || gameState.drawnChallengeCards.length === 0) {
                    console.log('⏳ Waiting for challenge cards to sync... (cards length: 0)');
                    // Modal will be shown when cards sync triggers updateGameUI
                    return;
                }

                console.log(`✅ Showing modal with ${gameState.drawnChallengeCards.length} challenge cards`);

                // Get first guesser name safely
                const firstGuesser = gameState.players?.[gameState.firstGuesser];
                const firstGuesserName = firstGuesser?.name || 'Player';

                // V4.96: Check if current player is the first guesser (only they can select)
                // In local mode, always allow selection (same device). In online mode, check user ID.
                const playerIds = window.playerIds || [];
                const firstGuesserId = playerIds[gameState.firstGuesser];
                const isFirstGuesser = GameModeManager.isLocal() || firstGuesserId === window.currentUserId;
                const instructionText = isFirstGuesser
                    ? `<strong>${firstGuesserName}</strong>, choose one challenge card:`
                    : `Waiting for <strong>${firstGuesserName}</strong> to choose a challenge card...`;

                // Show challenge cards UI
                modalContent.innerHTML = `
                    <h2>Challenge Card Selection</h2>
                    <p style="margin-bottom: 20px;">${instructionText}</p>
                    <div id="challengeCardsContainer" style="display: grid; gap: 15px;">
                        ${gameState.drawnChallengeCards.map((cardData, idx) => {
                            const challenge = cardData.challenge;
                            const roundsAvailable = cardData.roundsAvailable;
                            const categoryEmoji = {
                                'movies': '🎬',
                                'countries': '🌍',
                                'companies': '🏢',
                                'sports': '🏈'
                            };
                            const available = getAvailableTokensForCategory(challenge.category);

                            // V4.88: Check if this category was used in previous round (for carryover display)
                            // Note: draftPool/centerToken are cleared by endRound(), but previousCategory persists
                            const wasPreviousCategory = (gameState.previousCategory === challenge.category);
                            const tokensNeeded = 13; // Always need 13 for a new round

                            const canSelect = available >= tokensNeeded;
                            const isNew = roundsAvailable === 1;

                            // V4.92: Only first guesser can click cards
                            const isClickable = canSelect && isFirstGuesser;

                            return `
                                <div class="challenge-card ${!canSelect ? 'disabled' : ''}"
                                     onclick="${isClickable ? `selectChallengeCard(${idx})` : ''}"
                                     style="background: ${canSelect ? 'white' : '#f5f5f5'};
                                            padding: 20px;
                                            border-radius: 12px;
                                            border: 3px solid ${canSelect ? '#764ba2' : '#ddd'};
                                            cursor: ${isClickable ? 'pointer' : (canSelect ? 'default' : 'not-allowed')};
                                            opacity: ${isFirstGuesser ? '1' : '0.7'};
                                            transition: all 0.2s;
                                            position: relative;">
                                    ${!isNew ? `
                                        <div style="position: absolute;
                                                    top: 10px;
                                                    right: 10px;
                                                    background: #ff9800;
                                                    color: white;
                                                    padding: 4px 10px;
                                                    border-radius: 12px;
                                                    font-size: 11px;
                                                    font-weight: bold;">
                                            Round ${roundsAvailable}
                                        </div>
                                    ` : ''}
                                    <div style="font-size: 32px; margin-bottom: 10px;">${categoryEmoji[challenge.category]}</div>
                                    <div style="font-weight: bold; font-size: 18px; color: #764ba2; margin-bottom: 5px;">
                                        ${challenge.category.charAt(0).toUpperCase() + challenge.category.slice(1)}
                                    </div>
                                    <div style="font-size: 16px; color: #333; margin-bottom: 5px;">${challenge.name}</div>
                                    <div style="font-size: 12px; color: ${canSelect ? '#666' : '#999'};">
                                        ${(() => {
                                            // V5.1.19: Check THIS category's persistent tokens (not just previous round)
                                            const centerToken = gameState.categoryCenterTokens[challenge.category];
                                            const draftCount = gameState.categoryDraftPools[challenge.category]?.length || 0;
                                            const hasPersistentTokens = centerToken || draftCount > 0;

                                            // Debug logging
                                            if (hasPersistentTokens) {
                                                console.log(`🔍 Modal rendering ${challenge.category}: center="${centerToken?.name}", draft=${draftCount}`);
                                            }

                                            if (hasPersistentTokens && centerToken) {
                                                // Show center token name and draft pool count
                                                return `🔄 Has persistent tokens<br>Center: <strong>${centerToken.name}</strong><br>${draftCount} in draft pool (${available} total available)`;
                                            } else if (hasPersistentTokens) {
                                                return `🔄 Has persistent tokens<br>${draftCount} in draft pool (${available} total available)`;
                                            } else {
                                                return canSelect ? `${available} tokens available` : '⚠️ Not enough tokens';
                                            }
                                        })()}
                                    </div>
                                </div>
                            `;
                        }).join('')}
                    </div>
                `;
            } else {
                // Show manual selection UI (existing)
                modalContent.innerHTML = `
                    <h2>Select Category & Challenge</h2>
                    <p style="margin-bottom: 20px;"><strong id="firstGuesserName">${getPlayerByIndex(gameState.firstGuesser).name}</strong>, choose a category and challenge for this round:</p>

                    <div class="form-group">
                        <label>Category:</label>
                        <select id="categorySelect" onchange="updateChallengeOptions()">
                            <option value="">-- Select Category --</option>
                            <option value="movies">🎬 Movies</option>
                            <option value="countries">🌍 Countries</option>
                            <option value="companies">🏢 Companies</option>
                            <option value="sports">🏈 Sports</option>
                        </select>
                    </div>

                    <div class="form-group">
                        <label>Challenge:</label>
                        <select id="challengeSelect">
                            <option value="">-- Select Challenge --</option>
                        </select>
                        <p id="categoryWarning" style="color: #dc3545; margin-top: 5px; display: none;">
                            ⚠️ Not enough tokens in this category. Please choose another.
                        </p>
                    </div>

                    <button class="btn btn-primary" onclick="confirmCategorySelection()" style="width: 100%; margin-top: 20px;">Start Round</button>
                `;
            }

            modal.classList.add('active');
            console.log('✅ Modal active class added');

            // CRITICAL: Update lockout state AFTER modal is active
            // This ensures players who passed are unlocked to see the modal
            updateLockedOutState();
            console.log('✅ Called updateLockedOutState() after modal activated');
        }

        function updateCategoryModalTokenCounts() {
            // Only update if modal is active and showing challenge cards
            const modal = document.getElementById('categoryModal');
            if (!modal || !modal.classList.contains('active') || gameState.challengeMode !== 'cards') {
                return;
            }

            // Update each challenge card's token count display
            gameState.drawnChallengeCards.forEach((cardData, idx) => {
                const challenge = cardData.challenge;
                const available = getAvailableTokensForCategory(challenge.category);

                // Check if there are existing tokens in draft pool from this category
                const hasExistingDraft = (gameState.previousCategory === challenge.category && gameState.draftPool.length > 0);
                const existingTokenCount = hasExistingDraft ? (1 + gameState.draftPool.length) : 0;
                const tokensNeeded = hasExistingDraft ? Math.max(0, 13 - existingTokenCount) : 13;
                const canSelect = available >= tokensNeeded;

                // Find the challenge card element and update its token count text
                const cards = document.querySelectorAll('.challenge-card');
                if (cards[idx]) {
                    const tokenInfo = cards[idx].querySelector('div[style*="font-size: 12px"]');
                    if (tokenInfo) {
                        tokenInfo.innerHTML = hasExistingDraft ?
                            `🔄 ${existingTokenCount} in draft pool<br>${available} in pool · Need ${tokensNeeded} more` :
                            canSelect ? `${available} tokens available` : '⚠️ Not enough tokens';
                        tokenInfo.style.color = canSelect ? '#666' : '#999';
                    }

                    // Update card styling if it's no longer selectable
                    if (!canSelect) {
                        cards[idx].style.background = '#f5f5f5';
                        cards[idx].style.border = '3px solid #ddd';
                        cards[idx].style.cursor = 'not-allowed';
                        cards[idx].onclick = null;
                    }
                }
            });
        }

        async function selectChallengeCard(cardIndex) {
            // Turn validation for online mode - check if this player is the first guesser
            if (GameModeManager.isOnline()) {
                const playerIds = window.playerIds || [];
                const firstGuesserId = playerIds[gameState.firstGuesser];
                const isFirstGuesser = firstGuesserId === window.currentUserId;

                if (!isFirstGuesser) {
                    showNotification("Wait for your turn! Only the first guesser can select the challenge card.", 'warning');
                    return;
                }
            }

            const cardData = gameState.drawnChallengeCards[cardIndex];
            const challenge = cardData.challenge;
            gameState.currentChallenge = challenge;

            // Mark this challenge as played
            gameState.playedChallenges.push({
                name: challenge.name,
                category: challenge.category
            });

            // Check if this is the same category as previous round
            const sameCategoryAsPrevious = (challenge.category === gameState.previousCategory);

            // Update category tracking
            gameState.selectedCategory = challenge.category;

            // Close modal
            document.getElementById('categoryModal').classList.remove('active');

            // V5.1.19: Handle token drawing with per-category persistence
            let carryoverMessage = '';
            const category = challenge.category;

            // Check existing tokens for THIS category (any category can have persistent tokens)
            const existingCenter = gameState.categoryCenterTokens[category];
            const existingDraft = gameState.categoryDraftPools[category];
            const existingTokenCount = (existingCenter ? 1 : 0) + existingDraft.length;

            if (existingTokenCount > 0) {
                // This category has persistent tokens: top up to 13
                const tokensNeeded = 13 - existingTokenCount;

                if (tokensNeeded > 0) {
                    const newTokens = drawTokens(tokensNeeded, category);

                    if (newTokens.length < tokensNeeded && gameState.categoryPools[category].length === 0) {
                        showNotification(`Only ${existingTokenCount} tokens available (${existingTokenCount} carried over). Continuing with reduced pool.`, 'warning');
                    }

                    // If no center token, first new token becomes center
                    if (!existingCenter && newTokens.length > 0) {
                        gameState.categoryCenterTokens[category] = newTokens.shift();
                    }

                    // Add new tokens to draft pool
                    gameState.categoryDraftPools[category].push(...newTokens);

                    carryoverMessage = `🔄 ${existingTokenCount} tokens carried over + ${newTokens.length} new tokens drawn`;
                    showNotification(`Round ${gameState.round} started! Category: ${category.toUpperCase()} - ${challenge.name}\n${existingTokenCount} tokens carried over, ${newTokens.length} new tokens added.`, 'success');
                } else {
                    // We already have enough tokens from previous time this category was played
                    carryoverMessage = `🔄 All ${existingTokenCount} tokens carried over`;
                    showNotification(`Round ${gameState.round} started! Category: ${category.toUpperCase()} - ${challenge.name}\nAll ${existingTokenCount} tokens carried over.`, 'success');
                }

                // Update legacy fields for compatibility
                gameState.centerToken = gameState.categoryCenterTokens[category];
                gameState.draftPool = gameState.categoryDraftPools[category];
            } else {
                // First time playing this category: draw 13 fresh tokens
                const tokens = drawTokens(13, category);

                if (tokens.length < 13) {
                    showNotification(`Only ${tokens.length} tokens available in this category! Continuing with reduced pool.`, 'warning');
                }

                // 1 goes to center
                gameState.categoryCenterTokens[category] = tokens[0];

                // 12 go to draft pool (or less if not enough tokens)
                gameState.categoryDraftPools[category] = tokens.slice(1);

                // Update legacy fields for compatibility
                gameState.centerToken = tokens[0];
                gameState.draftPool = tokens.slice(1);

                carryoverMessage = ''; // No carryover for first time
                showNotification(`Round ${gameState.round} started! Category: ${category.toUpperCase()} - ${challenge.name}`, 'success');
            }

            // Update carryover info display
            const carryoverInfo = document.getElementById('tokenCarryoverInfo');
            if (carryoverMessage) {
                carryoverInfo.textContent = carryoverMessage;
                carryoverInfo.style.display = 'block';
            } else {
                carryoverInfo.style.display = 'none';
            }

            // Update previous category for next round
            gameState.previousCategory = challenge.category;

            // Reset round state
            gameState.passedPlayers = new Set();
            // Don't clear lastToPass - it persists across rounds until someone else earns it
            gameState.currentPlayer = gameState.firstGuesser;
            gameState.selectedDraftToken = null;

            // Sync to Firebase if online mode
            if (GameModeManager.isOnline()) {
                await GameModeManager.updateGameState({
                    currentChallenge: challenge,
                    playedChallenges: gameState.playedChallenges,
                    selectedCategory: gameState.selectedCategory,
                    previousCategory: gameState.previousCategory,
                    centerToken: gameState.centerToken,
                    draftPool: gameState.draftPool,
                    passedPlayers: Array.from(gameState.passedPlayers),
                    currentPlayer: gameState.currentPlayer,
                    selectedDraftToken: null,
                    showModal: false  // V4.96: Hide modal for all players after selection
                });
                console.log('✅ Synced challenge selection + showModal=false to Firebase');
            }

            // Update UI
            updateGameUI();
        }

        function updateChallengeOptions() {
            const category = document.getElementById('categorySelect').value;
            const challengeSelect = document.getElementById('challengeSelect');
            const warning = document.getElementById('categoryWarning');

            if (!category) {
                challengeSelect.innerHTML = '<option value="">-- Select Challenge --</option>';
                warning.style.display = 'none';
                return;
            }

            // Check if category has enough tokens
            const availableTokens = getAvailableTokensForCategory(category);
            if (availableTokens < 13) {
                warning.style.display = 'block';
                challengeSelect.innerHTML = '<option value="">-- Select Challenge --</option>';
                challengeSelect.disabled = true;
                return;
            }

            warning.style.display = 'none';
            challengeSelect.disabled = false;

            // Populate challenges for this category
            const categoryChallenges = CHALLENGES.filter(c => c.category === category);
            challengeSelect.innerHTML = '<option value="">-- Select Challenge --</option>';

            categoryChallenges.forEach((challenge, idx) => {
                const option = document.createElement('option');
                option.value = idx;
                option.textContent = challenge.name;
                option.dataset.category = challenge.category;
                option.dataset.stat = challenge.stat;
                challengeSelect.appendChild(option);
            });
        }

        function getAvailableTokensForCategory(category) {
            // V5.1.19: Track tokens not yet dealt + tokens persisting in category-specific draft pool + center token
            // Each category has its own persistent draft pool that remains when replayed

            // Count tokens still in category pool (not yet drawn)
            const poolSize = gameState.categoryPools[category]?.length || 0;

            // Count tokens in THIS category's draft pool (persist across rounds)
            const draftPoolSize = gameState.categoryDraftPools[category]?.length || 0;

            // Count center token for THIS category
            const centerSize = gameState.categoryCenterTokens[category] ? 1 : 0;

            const available = poolSize + draftPoolSize + centerSize;
            console.log(`📊 Category ${category}: ${poolSize} in pool + ${draftPoolSize} in draft + ${centerSize} center = ${available} available`);
            return Math.max(0, available);
        }

        function confirmCategorySelection() {
            const category = document.getElementById('categorySelect').value;
            const challengeIdx = document.getElementById('challengeSelect').value;

            if (!category || challengeIdx === '') {
                showNotification('Please select both category and challenge!', 'warning');
                return;
            }

            // Get selected challenge
            const categoryChallenges = CHALLENGES.filter(c => c.category === category);
            gameState.currentChallenge = categoryChallenges[parseInt(challengeIdx)];
            gameState.selectedCategory = category;

            // Close modal
            document.getElementById('categoryModal').classList.remove('active');

            // V5.1.19: Check existing tokens for THIS category (not just previous round)
            const existingCenter = gameState.categoryCenterTokens[category];
            const existingDraft = gameState.categoryDraftPools[category];
            const existingTokens = (existingCenter ? 1 : 0) + existingDraft.length;

            if (existingTokens > 0) {
                // This category has persistent tokens: top up to 13
                const tokensNeeded = 13 - existingTokens;

                console.log(`🔄 Category ${category} has ${existingTokens} persistent tokens, drawing ${tokensNeeded} more to reach 13`);

                if (tokensNeeded > 0) {
                    const newTokens = drawTokens(tokensNeeded, category);

                    // If no center token, first new token becomes center
                    if (!existingCenter && newTokens.length > 0) {
                        gameState.categoryCenterTokens[category] = newTokens.shift();
                    }

                    // Rest go to draft pool
                    gameState.categoryDraftPools[category].push(...newTokens);
                }

                // Update legacy fields for compatibility
                gameState.centerToken = gameState.categoryCenterTokens[category];
                gameState.draftPool = gameState.categoryDraftPools[category];
            } else {
                // First time playing this category: draw 13 fresh
                console.log(`🆕 First time playing ${category}: drawing 13 fresh tokens`);

                const tokens = drawTokens(13, category);

                if (tokens.length < 13) {
                    showNotification('Not enough tokens in this category!', 'error');
                    return;
                }

                // 1 goes to center
                gameState.categoryCenterTokens[category] = tokens[0];

                // 12 go to draft pool
                gameState.categoryDraftPools[category] = tokens.slice(1);

                // Update legacy fields for compatibility
                gameState.centerToken = tokens[0];
                gameState.draftPool = tokens.slice(1);
            }

            // Reset round state
            gameState.passedPlayers = new Set();
            // Don't clear lastToPass - it persists across rounds until someone else earns it
            gameState.currentPlayer = gameState.firstGuesser;
            gameState.selectedDraftToken = null;

            // Update UI
            updateGameUI();

            showNotification(`Round ${gameState.round} started! Category: ${category.toUpperCase()}`, 'success');
        }

        function drawTokens(count, category) {
            const pool = gameState.categoryPools[category];
            const drawn = [];

            for (let i = 0; i < count && pool.length > 0; i++) {
                const randomIndex = Math.floor(Math.random() * pool.length);
                const token = pool.splice(randomIndex, 1)[0];
                // V5.1.15: Add category property for token tracking
                token.category = category;
                drawn.push(token);
            }

            return drawn;
        }

        // ===== UI UPDATES =====
        function updateGameUI() {
            // Update round number
            const roundNumber = document.getElementById('roundNumber');
            if (roundNumber) {
                roundNumber.textContent = `${gameState.round} / ${gameState.maxRounds}`;
            }

            // Update player name display
            const playerNameDisplay = document.getElementById('playerNameDisplay');
            if (playerNameDisplay) {
                if (GameModeManager.isOnline() && window.playerIds && window.currentUserId) {
                    const myPlayerIndex = window.playerIds.indexOf(window.currentUserId);
                    if (myPlayerIndex >= 0 && gameState.players[myPlayerIndex]) {
                        const playerName = gameState.players[myPlayerIndex].name;
                        const isLockedOut = gameState.lockedOutPlayers && gameState.lockedOutPlayers.has(myPlayerIndex);
                        playerNameDisplay.textContent = `Playing as: ${playerName}${isLockedOut ? ' (OUT)' : ''}`;
                    }
                } else if (gameState.players[gameState.currentPlayer]) {
                    // Local mode - show current turn player
                    const playerName = gameState.players[gameState.currentPlayer].name;
                    const isLockedOut = gameState.lockedOutPlayers && gameState.lockedOutPlayers.has(gameState.currentPlayer);
                    playerNameDisplay.textContent = `Current Turn: ${playerName}${isLockedOut ? ' (OUT)' : ''}`;
                }
            }

            // Update challenge info (only if challenge selected)
            if (gameState.currentChallenge) {
                const challengeInfo = document.getElementById('challengeInfo');
                if (challengeInfo) challengeInfo.style.display = 'block';

                const challengeName = document.getElementById('challengeName');
                if (challengeName) challengeName.textContent = gameState.currentChallenge.name;

                const statName = document.getElementById('statName');
                if (statName) statName.textContent = 'Higher or Lower';
            }

            // Update center token (only if exists)
            if (gameState.centerToken) {
                const centerTokenArea = document.getElementById('centerTokenArea');
                if (centerTokenArea) centerTokenArea.style.display = 'block';
                renderCenterToken();
            }

            // Update draft pool
            renderDraftPool();

            // Update players
            renderPlayers();

            // Update action buttons
            updateActionButtons();

            // Update locked out overlay
            updateLockedOutState();

            // Update category modal token counts if modal is active
            updateCategoryModalTokenCounts();
        }

        function updateLockedOutState() {
            // V4.97.23: NEVER show lockout overlay when game is ending or game end screen is active
            if (window.gameEnding || gameState.gameEnding) {
                const overlay = document.getElementById('lockedOutOverlay');
                const gameScreen = document.getElementById('gameScreen');
                if (overlay) overlay.classList.remove('active');
                if (gameScreen) gameScreen.classList.remove('locked-out');
                console.log('🔓 Game ending - lockout disabled for all players');
                return;
            }

            const gameEndScreen = document.getElementById('gameEndScreen');
            if (gameEndScreen && gameEndScreen.classList.contains('active')) {
                const overlay = document.getElementById('lockedOutOverlay');
                const gameScreen = document.getElementById('gameScreen');
                if (overlay) overlay.classList.remove('active');
                if (gameScreen) gameScreen.classList.remove('locked-out');
                console.log('🔓 Game end screen active - lockout disabled for all players');
                return;
            }

            // V4.75: During roundEnd phase, NEVER show lockout overlay
            if (gameState.phase === 'roundEnd') {
                const overlay = document.getElementById('lockedOutOverlay');
                const gameScreen = document.getElementById('gameScreen');
                if (overlay) overlay.classList.remove('active');
                if (gameScreen) gameScreen.classList.remove('locked-out');
                console.log('🔓 Round end phase - lockout disabled for all players');
                return;
            }

            // CRITICAL: Check modal state FIRST before anything else
            const modal = document.getElementById('categoryModal');
            const isModalActive = modal && modal.classList.contains('active');

            // If modal is active, NEVER show lockout overlay (it has lower z-index)
            if (isModalActive) {
                const overlay = document.getElementById('lockedOutOverlay');
                const gameScreen = document.getElementById('gameScreen');
                if (overlay) overlay.classList.remove('active');
                if (gameScreen) gameScreen.classList.remove('locked-out');
                console.log('🔓 Modal active - lockout disabled');
                return; // Exit immediately
            }

            // V4.96: Check if we're in round transition (modal being shown)
            // Modal open = don't show lockout overlay
            const isRoundTransition = gameState.showModal === true;

            // Get player index for logging
            let myPlayerIndex = gameState.currentPlayer;
            if (GameModeManager.isOnline() && window.playerIds && window.currentUserId) {
                myPlayerIndex = window.playerIds.indexOf(window.currentUserId);
            }

            console.log(`🔍 V4.96 updateLockedOutState - Player ${myPlayerIndex}: isModalActive=${isModalActive}, showModal=${gameState.showModal}, isRoundTransition=${isRoundTransition}, hasPassed=${gameState.passedPlayers.has(myPlayerIndex)}`);

            if (isRoundTransition) {
                // Round transition - hide lockout overlay regardless of pass state
                const overlay = document.getElementById('lockedOutOverlay');
                const gameScreen = document.getElementById('gameScreen');
                if (overlay) overlay.classList.remove('active');
                if (gameScreen) gameScreen.classList.remove('locked-out');
                console.log(`🔓 Player ${myPlayerIndex} unlocked - round transition (showModal=true)`);
                return; // Exit early
            }

            // V4.97.13: Check BOTH passed and locked out status
            const hasPassed = gameState.passedPlayers.has(myPlayerIndex);
            const isLockedOut = gameState.lockedOutPlayers.has(myPlayerIndex);
            const shouldShowLockout = hasPassed || isLockedOut;

            const overlay = document.getElementById('lockedOutOverlay');
            const gameScreen = document.getElementById('gameScreen');

            if (shouldShowLockout) {
                // Show overlay and grey out screen
                if (overlay) overlay.classList.add('active');
                if (gameScreen) gameScreen.classList.add('locked-out');
                console.log(`🔒 Player ${myPlayerIndex} locked out - hasPassed=${hasPassed}, isLockedOut=${isLockedOut}`);
            } else {
                // Hide overlay and restore normal state
                if (overlay) overlay.classList.remove('active');
                if (gameScreen) gameScreen.classList.remove('locked-out');
            }
        }

        function renderCenterToken() {
            const token = gameState.centerToken;
            const container = document.getElementById('centerToken');

            // Safety check - don't render if no token or challenge selected yet
            if (!token || !gameState.currentChallenge) {
                if (container) container.innerHTML = '';
                return;
            }

            const statField = gameState.currentChallenge.stat;
            const statValue = token.stats[statField];

            container.innerHTML = `
                <div class="token-name">${token.name}</div>
                <div class="token-value">${formatNumber(statValue)}</div>
                <div class="token-tags">
                    ${token.tags.map(tag => {
                        const color = getTagColor(tag);
                        return `<span class="token-tag" style="background-color: ${color}; color: white; font-weight: bold;">${tag}</span>`;
                    }).join('')}
                </div>
            `;
        }

        // V5.1.14: Get color for tag based on letter+number format (A1-A5, B1-B5, etc.)
        function getTagColor(tag) {
            // Extract letter and number from tag (e.g., "A1" -> letter="A", number=1)
            const match = tag.match(/^([A-Z])(\d+)$/);
            if (!match) {
                // Fallback for non-standard tags
                return 'hsl(240, 50%, 50%)';
            }

            const letter = match[1];
            const number = parseInt(match[2]);

            // Assign base hue based on letter (A=0°, B=30°, C=60°, etc.)
            // Each letter gets a distinct color family
            const letterIndex = letter.charCodeAt(0) - 65; // A=0, B=1, C=2, etc.
            const baseHue = (letterIndex * 30) % 360; // 30° steps around color wheel

            // Vary lightness based on number (1=darkest, 5=lightest)
            const baseLightness = 35;
            const lightnessStep = 10; // Each number adds 10% lightness
            const lightness = baseLightness + ((number - 1) * lightnessStep);

            return `hsl(${baseHue}, 75%, ${lightness}%)`;
        }

        function renderDraftPool() {
            const container = document.getElementById('draftPool');
            if (!container) return;

            const pool = gameState.draftPool;
            const poolCount = document.getElementById('poolCount');
            if (poolCount) {
                poolCount.textContent = pool.length;
            }

            // Safety check - don't render if no challenge selected yet
            if (!gameState.currentChallenge) {
                container.innerHTML = '';
                return;
            }

            const statField = gameState.currentChallenge.stat;

            container.innerHTML = pool.map(token => {
                const statValue = token.stats?.[statField];
                const tags = token.tags || [];
                return `
                    <div class="token ${gameState.selectedDraftToken?.id === token.id ? 'selected' : ''}"
                         onclick="selectDraftToken('${token.id}')">
                        <div class="token-name">${token.name}</div>
                        <div class="token-value">${formatNumber(statValue)}</div>
                        <div class="token-tags">
                            ${tags.map(tag => {
                                const color = getTagColor(tag);
                                return `<span class="token-tag" style="background-color: ${color}; color: white; font-weight: bold;">${tag}</span>`;
                            }).join('')}
                        </div>
                    </div>
                `;
            }).join('');
        }

        function renderPlayers() {
            const container = document.getElementById('playersList');

            const playersArray = getPlayersArray();
            container.innerHTML = playersArray.map((player, index) => {
                const isCurrent = index === gameState.currentPlayer;
                const isFirstGuesser = index === gameState.firstGuesser;
                const hasPassed = gameState.passedPlayers.has(index);
                const isLockedOut = gameState.lockedOutPlayers.has(index);
                const isOut = hasPassed || isLockedOut; // V5.0: Show (Out) for passed OR locked out players
                const isLastStanding = index === gameState.lastToPass;

                // Calculate tag counts for this player
                const tagCounts = getPlayerTagCounts(player);
                const tagDisplay = Object.entries(tagCounts)
                    .filter(([tag, count]) => count > 0)
                    .sort(([tagA], [tagB]) => tagA.localeCompare(tagB))
                    .map(([tag, count]) => {
                        const hasSet = count >= 2;
                        const color = hasSet ? '#28a745' : '#666';
                        const weight = hasSet ? 'bold' : 'normal';
                        return `<span style="color: ${color}; font-weight: ${weight};">${tag}:${count}</span>`;
                    })
                    .join(' ');

                // V5.0: Display bonus cards (visible to all players)
                // V5.1.14: Added title attribute for hover tooltips
                const bonusCardsDisplay = player.bonusCards && player.bonusCards.length > 0
                    ? player.bonusCards.map(card => `
                        <div style="font-size: 10px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 3px 6px; border-radius: 4px; margin-bottom: 2px; cursor: help;" title="${card.description || card.name}">
                            ${card.name}
                        </div>
                    `).join('')
                    : '';

                // V5.0.2: Display active effects (multipliers, etc.)
                const activeEffectsDisplay = player.activeEffects && player.activeEffects.length > 0
                    ? player.activeEffects.map(effect => `
                        <div style="font-size: 10px; background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%); color: white; padding: 3px 6px; border-radius: 4px; margin-bottom: 2px; font-weight: bold;">
                            ✨ ${effect.name} ACTIVE ${effect.usesRemaining ? `(${effect.usesRemaining} use${effect.usesRemaining > 1 ? 's' : ''})` : ''}
                        </div>
                    `).join('')
                    : '';

                return `
                    <div class="player-info ${isCurrent ? 'current-player' : ''}">
                        <div class="player-name">
                            ${player.name}
                            ${isFirstGuesser ? '<span class="first-guesser-marker">1st</span>' : ''}
                            ${isLastStanding ? '<span class="last-standing-marker" title="Last Standing">🏆</span>' : ''}
                            ${isOut ? '<span style="color: #999;"> (Out)</span>' : ''}
                        </div>
                        <div class="player-score">${player.score || 0} pts</div>
                        <div class="player-stats">
                            Hand: ${player.hand?.length || 0} | This Round: ${player.thisRound?.length || 0}
                        </div>
                        ${tagDisplay ? `<div class="player-tags" style="font-size: 11px; margin-top: 5px; line-height: 1.4;">${tagDisplay}</div>` : ''}
                        ${activeEffectsDisplay ? `<div class="player-active-effects" style="margin-top: 5px;">${activeEffectsDisplay}</div>` : ''}
                        ${bonusCardsDisplay ? `<div class="player-bonus-cards" style="margin-top: 5px;">${bonusCardsDisplay}</div>` : ''}
                    </div>
                `;
            }).join('');
        }

        function getPlayerTagCounts(player) {
            // Firebase stores arrays as objects - convert to arrays
            const hand = Array.isArray(player.hand) ? player.hand : Object.values(player.hand || {});
            const thisRound = Array.isArray(player.thisRound) ? player.thisRound : Object.values(player.thisRound || {});
            const allTokens = [...hand, ...thisRound];
            const tagCounts = {};

            allTokens.forEach(token => {
                if (token && token.tags) {
                    const tags = Array.isArray(token.tags) ? token.tags : Object.values(token.tags || {});
                    tags.forEach(tag => {
                        tagCounts[tag] = (tagCounts[tag] || 0) + 1;
                    });
                }
            });

            return tagCounts;
        }

        function updateActionButtons() {
            const player = getPlayerByIndex(gameState.currentPlayer);

            // Check if current player has passed
            const hasPassed = gameState.passedPlayers.has(gameState.currentPlayer);

            // V5.0.3: Check if player has playable cards
            const hasPlayableCards = player.bonusCards && player.bonusCards.some(card =>
                card.type === 'playable' && !player.activeEffects.some(e => e.id === card.id)
            );

            // Disable all actions if player has passed
            if (hasPassed) {
                document.getElementById('cashOutBtn').disabled = true;
                document.getElementById('playCardBtn').disabled = true;
                document.getElementById('passBtn').disabled = true;
            } else {
                // Cash out button enabled if player has sets
                document.getElementById('cashOutBtn').disabled = !canCashOut(player);

                // V5.0.3: Play Card button enabled if player has playable cards
                document.getElementById('playCardBtn').disabled = !hasPlayableCards;

                // Pass button enabled if not passed
                document.getElementById('passBtn').disabled = false;
            }
        }

        // ===== DRAFT & GUESS =====
        function selectDraftToken(tokenId) {
            // Check if current player has passed
            if (gameState.passedPlayers.has(gameState.currentPlayer)) {
                showNotification("You have passed this round!", 'warning');
                return;
            }

            const token = gameState.draftPool.find(t => t.id === tokenId);
            if (!token) return;

            gameState.selectedDraftToken = token;
            renderDraftPool();

            // V5.1.14: Show guess area with new layout
            const guessArea = document.getElementById('guessArea');
            guessArea.style.display = 'block';
            guessArea.classList.add('active');
            document.getElementById('draftedTokenName').textContent = token.name;
            document.getElementById('draftedTokenName2').textContent = token.name;
        }

        function makeGuess(direction) {
            console.log('🎯 makeGuess called:', direction, 'selectedToken:', gameState.selectedDraftToken?.name);

            // V5.1.14: Hide guess area once choice is made
            const guessArea = document.getElementById('guessArea');
            if (guessArea) {
                guessArea.style.display = 'none';
            }

            // V4.97.6: Check if current player is locked out
            if (gameState.lockedOutPlayers && gameState.lockedOutPlayers.has(gameState.currentPlayer)) {
                showNotification("You are locked out for this round!", 'warning');
                return;
            }

            // Check if current player has passed
            if (gameState.passedPlayers.has(gameState.currentPlayer)) {
                showNotification("You have passed this round!", 'warning');
                return;
            }

            // Turn validation for online mode
            if (GameModeManager.isOnline() && !GameModeManager.isMyTurn()) {
                showNotification("Wait for your turn!", 'warning');
                return;
            }

            if (!gameState.selectedDraftToken) {
                showNotification("Please select a token from the draft pool first!", 'warning');
                return;
            }

            const drafted = gameState.selectedDraftToken;
            const center = gameState.centerToken;
            const stat = gameState.currentChallenge.stat;

            const draftedValue = drafted.stats[stat];
            const centerValue = center.stats[stat];

            let isCorrect = false;
            if (direction === 'higher') {
                isCorrect = draftedValue > centerValue;
            } else {
                isCorrect = draftedValue < centerValue;
            }

            if (isCorrect) {
                handleCorrectGuess(drafted, center, direction);
            } else {
                handleWrongGuess(drafted, direction);
            }
        }

        function handleCorrectGuess(drafted, center, direction) {
            const player = GameModeManager.getCurrentPlayer();

            // Award 1 point
            let pointsEarned = 1;
            player.correctGuesses += 1;

            // V5.0.6: Check for Genius passive effect (+1 point per correct guess)
            const hasGenius = player.bonusCards && player.bonusCards.some(card => card.effect === 'guess_bonus');
            if (hasGenius) {
                pointsEarned += 1;
                console.log(`🧠 ${player.name} has Genius: +1 bonus point`);
            }

            player.score += pointsEarned;

            // Collect center token to "this round" pile (Firebase stores arrays as objects)
            if (!Array.isArray(player.thisRound)) {
                player.thisRound = Object.values(player.thisRound || {});
            }
            player.thisRound.push(center);

            // Calculate new state
            const newCenterToken = drafted;
            const newDraftPool = gameState.draftPool.filter(t => t.id !== drafted.id);

            // Create action metadata for opponent feedback
            const actionData = {
                type: 'correct_guess',
                playerName: player.name,
                draftedToken: drafted.name,
                oldCenterToken: center.name,
                direction: direction,
                timestamp: Date.now()
            };

            // Show success animation on center token
            const centerEl = document.getElementById('centerToken');
            centerEl.classList.add('animate-correct-flash');
            setTimeout(() => centerEl.classList.remove('animate-correct-flash'), 600);

            // Floating points animation
            showFloatingPoints(`+${pointsEarned}`, centerEl);

            // Show success notification (V4.97.8: broadcast to all players)
            const geniusText = hasGenius ? ' 🧠' : '';
            showNotification(`✅ Correct! ${player.name} earns ${pointsEarned} point${pointsEarned > 1 ? 's' : ''}!${geniusText}`, 'success', true);

            // Clear selection
            const newSelectedDraftToken = null;

            // V4.97: Update state based on mode
            if (GameModeManager.isOnline()) {
                // ONLINE MODE: Only send to Firebase, DO NOT update local state
                // The Firebase sync listener will update our local state
                const playerIds = Object.keys(gameState.players);
                const currentPlayerId = playerIds[gameState.currentPlayer];

                console.log('🔄 Syncing correct guess to Firebase:');
                console.log('  New center token:', newCenterToken.name);
                console.log('  Draft pool size:', newDraftPool.length);

                GameModeManager.updatePlayer(currentPlayerId, {
                    score: player.score,
                    correctGuesses: player.correctGuesses,
                    thisRound: player.thisRound
                });

                // V5.1.19: Update both legacy and category-specific fields for Firebase
                const category = gameState.selectedCategory;
                const updateData = {
                    centerToken: newCenterToken,
                    draftPool: newDraftPool,
                    selectedDraftToken: newSelectedDraftToken,
                    lastAction: actionData
                };

                // Add category-specific updates
                if (category) {
                    updateData[`categoryCenterTokens/${category}`] = newCenterToken;
                    updateData[`categoryDraftPools/${category}`] = newDraftPool;
                }

                GameModeManager.updateGameState(updateData);
            } else {
                // LOCAL MODE: Update state directly
                gameState.centerToken = newCenterToken;
                gameState.draftPool = newDraftPool;
                gameState.selectedDraftToken = newSelectedDraftToken;

                // V5.1.19: Also update category-specific center token
                const category = gameState.selectedCategory;
                if (category) {
                    gameState.categoryCenterTokens[category] = newCenterToken;
                    gameState.categoryDraftPools[category] = newDraftPool;
                }

                document.getElementById('guessArea').classList.remove('active');
            }

            // V4.97: Always call advanceTurn() after animation - it handles everything
            setTimeout(() => {
                console.log('⏰ Correct guess timeout fired - calling advanceTurn');
                updateGameUI();
                advanceTurn();
            }, 400);
        }

        function handleWrongGuess(drafted, direction) {
            const player = GameModeManager.getCurrentPlayer();

            // Show failure animation on center token
            const centerEl = document.getElementById('centerToken');
            centerEl.classList.add('animate-wrong-flash', 'animate-shake');
            setTimeout(() => {
                centerEl.classList.remove('animate-wrong-flash', 'animate-shake');
            }, 800);

            // Calculate new state
            const thisRoundArray = Array.isArray(player.thisRound) ? player.thisRound : Object.values(player.thisRound || {});
            const newDraftPool = [...gameState.draftPool, ...thisRoundArray];
            player.thisRound = [];

            // Create action metadata for opponent feedback
            const actionData = {
                type: 'wrong_guess',
                playerName: player.name,
                draftedToken: drafted.name,
                centerToken: gameState.centerToken.name,
                direction: direction,
                tokensLost: thisRoundArray.length,
                timestamp: Date.now()
            };

            // V4.97: Player becomes first guesser next round if no one passed yet
            const becomesFirstGuesser = gameState.passedPlayers.size === 0;
            if (becomesFirstGuesser) {
                gameState.firstGuesser = gameState.currentPlayer;
            }

            // V4.97: Lock out player for rest of round
            gameState.lockedOutPlayers.add(gameState.currentPlayer);

            console.log('❌ Wrong guess by', player.name, '- locked out for rest of round');
            console.log('🔍 DEBUG: lockedOutPlayers Set after add:', Array.from(gameState.lockedOutPlayers));

            // V4.97.7: Sync lockedOutPlayers to Firebase immediately so other players see (OUT)
            if (GameModeManager.isOnline()) {
                const lockedOutArray = Array.from(gameState.lockedOutPlayers);
                console.log('🔍 DEBUG: Syncing to Firebase:', lockedOutArray);

                // V4.97.10: Track timestamp to prevent Firebase listener from overwriting
                window.lastLockedOutPlayersUpdate = Date.now();

                GameModeManager.updateGameState({
                    lockedOutPlayers: lockedOutArray,
                    lockedOutPlayersTimestamp: window.lastLockedOutPlayersUpdate
                });
            }

            // V4.97.7: Update UI immediately to show (OUT) indicator
            updateGameUI();

            // V4.97.15: Removed showLockedOutModal() call - it creates duplicate modal with lockedOutOverlay
            // The lockedOutOverlay (managed by updateLockedOutState) is the correct UI element

            // Show failure notification (V4.97.8: broadcast to all players)
            const nextRoundMsg = becomesFirstGuesser ? ' Will go first next round!' : '';
            showNotification(`❌ Wrong! ${player.name} loses tokens but keeps ${player.score} points. OUT for this round.${nextRoundMsg}`, 'error', true);

            // V4.97.16: Update state based on mode - ALWAYS update draftPool with returned tokens
            if (GameModeManager.isOnline()) {
                const playerIds = Object.keys(gameState.players);
                const currentPlayerId = playerIds[gameState.currentPlayer];

                // Update player data
                const playerUpdates = {
                    thisRound: player.thisRound || []
                };
                if (player.wrongGuesses !== undefined) playerUpdates.wrongGuesses = player.wrongGuesses;
                if (player.hand !== undefined) playerUpdates.hand = player.hand;

                GameModeManager.updatePlayer(currentPlayerId, playerUpdates);

                // V4.97.16: CRITICAL FIX - Update draftPool in Firebase to include returned tokens
                GameModeManager.updateGameState({
                    draftPool: newDraftPool,
                    selectedDraftToken: null
                });
                console.log('🔍 DEBUG: Updated draftPool with returned tokens. New size:', newDraftPool.length);
            } else {
                // LOCAL MODE: Update state directly
                gameState.draftPool = newDraftPool;
                gameState.selectedDraftToken = null;
                document.getElementById('guessArea').classList.remove('active');
            }

            // V4.97: Always call advanceTurn() after animation - it handles round end if needed
            setTimeout(() => {
                console.log('⏰ Wrong guess timeout fired - calling advanceTurn');
                console.log('🔍 DEBUG: lockedOutPlayers Set before advanceTurn:', Array.from(gameState.lockedOutPlayers));
                updateGameUI();
                advanceTurn();
            }, 600);
        }

        function advanceTurn() {
            // V4.97: Track who just acted (for last player standing bonus)
            gameState.lastPlayerToAct = gameState.currentPlayer;

            console.log('🔄 advanceTurn called. Locked out players:', gameState.lockedOutPlayers.size, '/', getPlayerCount());

            // V4.97: Check if all players locked out (passed or picked wrong)
            const playerCount = GameModeManager.isLocal() ? getPlayerCount() : Object.keys(gameState.players).length;
            if (gameState.lockedOutPlayers.size === playerCount) {
                console.log('✅ All players locked out. Ending round... Last player to act:', gameState.lastPlayerToAct);

                // V4.97: In online mode, only the last player to act calls endRound()
                // Everyone else waits for Firebase sync to trigger the round transition
                if (GameModeManager.isOnline()) {
                    const playerIds = Object.keys(gameState.players);
                    const lastPlayerId = playerIds[gameState.lastPlayerToAct];
                    const isLastPlayer = lastPlayerId === window.currentUserId;

                    console.log(`🎯 Last player check: isLastPlayer=${isLastPlayer}, lastPlayerId=${lastPlayerId}, currentUserId=${window.currentUserId}`);

                    if (isLastPlayer) {
                        console.log('🎯 This player is last to act - calling endRound()');
                        endRound();
                    } else {
                        console.log('⏳ Not last player - waiting for Firebase sync');
                    }
                } else {
                    // Local mode: always call endRound()
                    endRound();
                }
                return;
            }

            // Move to next non-locked-out player
            let attempts = 0;
            do {
                gameState.currentPlayer = (gameState.currentPlayer + 1) % playerCount;
                attempts++;

                // Safety check: prevent infinite loop
                if (attempts > playerCount) {
                    console.error('❌ INFINITE LOOP DETECTED in advanceTurn!');
                    endRound();
                    return;
                }
            } while (gameState.lockedOutPlayers.has(gameState.currentPlayer));

            console.log('👤 Next player:', getPlayerByIndex(gameState.currentPlayer).name);

            // Sync to Firebase if online mode
            if (GameModeManager.isOnline()) {
                // V4.97.10: Track timestamp to prevent Firebase listener from overwriting
                window.lastLockedOutPlayersUpdate = Date.now();

                GameModeManager.updateGameState({
                    currentPlayer: gameState.currentPlayer,
                    lockedOutPlayers: Array.from(gameState.lockedOutPlayers),
                    passedPlayers: Array.from(gameState.passedPlayers),
                    lastPlayerToAct: gameState.lastPlayerToAct,
                    lockedOutPlayersTimestamp: window.lastLockedOutPlayersUpdate
                });
            }

            // V5.1.0: Check for Lucky passive effect (draw extra token at start of turn - with player choice)
            const currentPlayer = getPlayerByIndex(gameState.currentPlayer);
            const hasLucky = currentPlayer.bonusCards && currentPlayer.bonusCards.some(card => card.effect === 'draw_bonus');

            if (hasLucky && gameState.draftPool.length > 0) {
                // V5.1.0: Let player choose which token to draw with Lucky
                showTokenSelectionModal(
                    gameState.draftPool,
                    '🍀 Lucky - Choose Token',
                    `${currentPlayer.name}'s Lucky card! Choose a token to draw:`,
                    (tokenIndex) => {
                        const luckyToken = gameState.draftPool.splice(tokenIndex, 1)[0];

                        if (!Array.isArray(currentPlayer.thisRound)) {
                            currentPlayer.thisRound = Object.values(currentPlayer.thisRound || {});
                        }
                        currentPlayer.thisRound.push(luckyToken);

                        console.log(`🍀 ${currentPlayer.name} has Lucky: drew ${luckyToken.name}`);
                        showNotification(`🍀 ${currentPlayer.name}'s Lucky card drew ${luckyToken.name}!`, 'success');

                        // Update draft pool UI
                        renderDraftPool();

                        // Sync to Firebase if online
                        if (GameModeManager.isOnline()) {
                            const playerIds = Object.keys(gameState.players);
                            const playerId = playerIds[gameState.currentPlayer];
                            GameModeManager.updatePlayer(playerId, {
                                thisRound: currentPlayer.thisRound
                            });
                            GameModeManager.updateGameState({
                                draftPool: gameState.draftPool
                            });
                        }

                        // Continue with turn advancement
                        updateGameUI();
                    }
                );
                return; // Exit advanceTurn early, will be called after token selection
            }

            // Update UI
            updateGameUI();
        }

        // ===== CASH OUT =====
        function canCashOut(player) {
            // Firebase stores arrays as objects - convert to arrays
            const hand = Array.isArray(player.hand) ? player.hand : Object.values(player.hand || {});
            const thisRound = Array.isArray(player.thisRound) ? player.thisRound : Object.values(player.thisRound || {});
            const allTokens = [...hand, ...thisRound];
            const tagCounts = {};

            allTokens.forEach(token => {
                if (token && token.tags) {
                    const tags = Array.isArray(token.tags) ? token.tags : Object.values(token.tags || {});
                    tags.forEach(tag => {
                        tagCounts[tag] = (tagCounts[tag] || 0) + 1;
                    });
                }
            });

            // Check if any tag has 2+ tokens
            return Object.values(tagCounts).some(count => count >= 2);
        }

        function openCashOutModal() {
            const player = getPlayerByIndex(gameState.currentPlayer);

            // Convert to arrays if Firebase sent objects
            const hand = Array.isArray(player.hand) ? player.hand : Object.values(player.hand || {});
            const thisRound = Array.isArray(player.thisRound) ? player.thisRound : Object.values(player.thisRound || {});
            const allTokens = [...hand, ...thisRound];

            if (allTokens.length === 0) {
                showNotification('No tokens to cash out!', 'warning');
                return;
            }

            // Build tag groups
            const tagGroups = {};
            allTokens.forEach(token => {
                token.tags.forEach(tag => {
                    if (!tagGroups[tag]) {
                        tagGroups[tag] = [];
                    }
                    tagGroups[tag].push(token);
                });
            });

            // V5.1.12: Check if player has wildcard
            const hasWildcard = player.activeEffects && player.activeEffects.some(e =>
                e.effect === 'wildcard' && e.usesRemaining > 0
            );

            // V5.1.12: Also allow sets with 1+ token if wildcard active (can add wildcard slot)
            const validSets = Object.entries(tagGroups).filter(([tag, tokens]) =>
                hasWildcard ? tokens.length >= 1 : tokens.length >= 2
            );

            if (validSets.length === 0) {
                showNotification('No sets available to cash out!', 'warning');
                return;
            }

            // Build modal content
            const modal = document.getElementById('cashOutModal');
            const content = document.getElementById('cashOutContent');
            const wildcardNote = hasWildcard ? '<p style="color: #f59e0b; font-weight: bold; margin-bottom: 10px;">🌈 Wildcard Active! Click "Add Wildcard Slot" to add 1 extra token to any set</p>' : '';
            content.innerHTML = `<p style="margin-bottom: 15px; font-weight: bold;">💰 Cash Out Rules: 2 tokens = 2pts | 3 tokens = 5pts | 4 tokens = 8pts (max)</p>${wildcardNote}<p style="margin-bottom: 15px;">Select tokens from one set${hasWildcard ? ' (can add 1 wildcard)' : ''}:</p>`;

            // Show regular tag-matched sets
            validSets.forEach(([tag, tokens]) => {
                const setDiv = document.createElement('div');
                setDiv.className = 'cash-out-set';
                setDiv.style.cssText = 'background: #f8f8f8; padding: 15px; border-radius: 10px; margin-bottom: 15px;';

                const setHeader = document.createElement('div');
                setHeader.style.cssText = 'font-weight: bold; margin-bottom: 10px; color: #764ba2;';

                const maxSelect = Math.min(tokens.length, 4);
                const selectRange = tokens.length === 2 ? '2' : `2-${maxSelect}`;
                setHeader.textContent = `Tag ${tag} — You have ${tokens.length} token${tokens.length > 1 ? 's' : ''} (select ${selectRange})`;
                setDiv.appendChild(setHeader);

                const tokenList = document.createElement('div');
                tokenList.style.cssText = 'display: flex; gap: 8px; flex-wrap: wrap;';

                // V5.1.12: Render regular tokens
                tokens.forEach((token, idx) => {
                    const tokenBtn = document.createElement('button');
                    tokenBtn.className = 'cash-token-btn';
                    tokenBtn.textContent = token.name;
                    tokenBtn.style.cssText = 'padding: 8px 12px; border: 2px solid #ddd; background: white; border-radius: 8px; cursor: pointer; font-size: 13px;';
                    tokenBtn.dataset.tokenId = token.id;
                    tokenBtn.dataset.tag = tag;

                    tokenBtn.onclick = function() {
                        // Toggle selection
                        this.classList.toggle('selected');
                        if (this.classList.contains('selected')) {
                            this.style.background = 'linear-gradient(135deg, #667eea, #764ba2)';
                            this.style.color = 'white';
                            this.style.borderColor = '#764ba2';
                        } else {
                            this.style.background = 'white';
                            this.style.color = '#333';
                            this.style.borderColor = '#ddd';
                        }
                    };

                    tokenList.appendChild(tokenBtn);
                });

                // V5.1.12: Add wildcard slot button if wildcard active
                if (hasWildcard && tokens.length < 4) {
                    const wildcardSlotBtn = document.createElement('button');
                    wildcardSlotBtn.className = 'cash-token-btn wildcard-slot-btn';
                    wildcardSlotBtn.textContent = '🌈 Add Wildcard Slot';
                    wildcardSlotBtn.style.cssText = 'padding: 8px 12px; border: 2px dashed #f59e0b; background: rgba(251, 191, 36, 0.1); border-radius: 8px; cursor: pointer; font-size: 13px; color: #f59e0b; font-weight: bold;';
                    wildcardSlotBtn.dataset.isWildcardSlot = 'true';
                    wildcardSlotBtn.dataset.tag = tag;

                    wildcardSlotBtn.onclick = function() {
                        // V5.1.12: Open modal to select which token to use as wildcard
                        console.log('🌈 Opening wildcard token selection modal');

                        // Get all tokens NOT in this tag group (available for wildcard)
                        const selectedTokenIds = Array.from(document.querySelectorAll('.cash-token-btn.selected'))
                            .map(btn => btn.dataset.tokenId);
                        const availableForWildcard = allTokens.filter(t =>
                            !t.tags.includes(tag) && !selectedTokenIds.includes(t.id)
                        );

                        if (availableForWildcard.length === 0) {
                            showNotification('No tokens available for wildcard slot!', 'warning');
                            return;
                        }

                        // Show token selection modal
                        showTokenSelectionModal(
                            availableForWildcard,
                            'Select Wildcard Token',
                            '🌈 Choose any token to add to this set:',
                            (selectedIndex) => {
                                const wildcardToken = availableForWildcard[selectedIndex];
                                console.log(`🌈 Player selected wildcard token: ${wildcardToken.name}`);

                                // Create a token button for the wildcard choice
                                const wildcardBtn = document.createElement('button');
                                wildcardBtn.className = 'cash-token-btn selected'; // Auto-selected
                                wildcardBtn.textContent = `${wildcardToken.name} 🌈`;
                                wildcardBtn.style.cssText = 'padding: 8px 12px; border: 2px solid #f59e0b; background: linear-gradient(135deg, #fbbf24, #f59e0b); border-radius: 8px; cursor: pointer; font-size: 13px; color: white; font-weight: bold;';
                                wildcardBtn.dataset.tokenId = wildcardToken.id;
                                wildcardBtn.dataset.tag = tag;
                                wildcardBtn.dataset.isWildcard = 'true';

                                wildcardBtn.onclick = function() {
                                    // Allow deselection
                                    this.classList.toggle('selected');
                                    if (this.classList.contains('selected')) {
                                        this.style.background = 'linear-gradient(135deg, #fbbf24, #f59e0b)';
                                        this.style.borderColor = '#f59e0b';
                                    } else {
                                        this.style.background = 'rgba(251, 191, 36, 0.1)';
                                        this.style.borderColor = '#f59e0b';
                                    }
                                };

                                // Replace the "Add Wildcard Slot" button with the selected token
                                tokenList.replaceChild(wildcardBtn, wildcardSlotBtn);
                            }
                        );
                    };

                    tokenList.appendChild(wildcardSlotBtn);
                }

                setDiv.appendChild(tokenList);
                content.appendChild(setDiv);
            });

            modal.classList.add('active');
        }

        function closeCashOutModal() {
            document.getElementById('cashOutModal').classList.remove('active');
        }

        function showLockedOutModal(playerName) {
            const modal = document.getElementById('lockedOutModal');
            const message = document.getElementById('lockedOutMessage');
            message.textContent = `${playerName}, you guessed incorrectly and are locked out for the rest of this round.`;
            modal.classList.add('active');
            // V4.97.8: Modal stays up until round ends (closed in endRound)
        }

        function closeLockedOutModal() {
            document.getElementById('lockedOutModal').classList.remove('active');
        }

        function executeCashOut() {
            const player = getPlayerByIndex(gameState.currentPlayer);

            // Get selected tokens (need this early for block effect)
            const selectedBtns = document.querySelectorAll('.cash-token-btn.selected');

            // V5.0.6: Check if any opponent has an active block effect
            const blockingPlayer = gameState.players.find((p, idx) =>
                idx !== gameState.currentPlayer &&
                p.activeEffects &&
                p.activeEffects.some(e => e.effect === 'block' && e.targetNextCashout)
            );

            if (blockingPlayer) {
                // Get the tokens that were attempted to be cashed in
                const selectedTokenIds = Array.from(selectedBtns).map(btn => btn.dataset.tokenId);

                // Remove these tokens from player's hand and thisRound (LOST!)
                const hand = Array.isArray(player.hand) ? player.hand : Object.values(player.hand || {});
                const thisRound = Array.isArray(player.thisRound) ? player.thisRound : Object.values(player.thisRound || {});

                selectedTokenIds.forEach(tokenId => {
                    // Remove from hand
                    const handIndex = hand.findIndex(t => t.id === tokenId);
                    if (handIndex > -1) {
                        player.hand.splice(handIndex, 1);
                    }

                    // Remove from thisRound
                    const thisRoundIndex = thisRound.findIndex(t => t.id === tokenId);
                    if (thisRoundIndex > -1) {
                        player.thisRound.splice(thisRoundIndex, 1);
                    }
                });

                // Find and remove the block effect
                const blockEffect = blockingPlayer.activeEffects.find(e => e.effect === 'block' && e.targetNextCashout);
                const effectIndex = blockingPlayer.activeEffects.indexOf(blockEffect);
                blockingPlayer.activeEffects.splice(effectIndex, 1);

                showNotification(`🛡️ ${blockingPlayer.name}'s Veto blocked the cash-in! ${selectedTokenIds.length} tokens lost!`, 'error');
                console.log(`🛡️ ${blockingPlayer.name} blocked ${player.name}'s cash-in - ${selectedTokenIds.length} tokens removed from game`);

                closeCashOutModal();
                renderPlayers();

                // Sync to Firebase if online
                if (GameModeManager.isOnline()) {
                    const playerIds = Object.keys(gameState.players);
                    const playerId = playerIds[gameState.currentPlayer];
                    const blockerId = playerIds[gameState.players.indexOf(blockingPlayer)];

                    GameModeManager.updatePlayer(playerId, {
                        hand: player.hand,
                        thisRound: player.thisRound
                    });

                    GameModeManager.updatePlayer(blockerId, {
                        activeEffects: blockingPlayer.activeEffects
                    });
                }

                return;
            }

            if (selectedBtns.length < 2) {
                showNotification('Must select at least 2 tokens!', 'warning');
                return;
            }

            if (selectedBtns.length > 4) {
                showNotification('Can only cash out up to 4 tokens (max points)!', 'warning');
                return;
            }

            // Verify all selected tokens share a common tag
            const selectedTokenIds = Array.from(selectedBtns).map(btn => btn.dataset.tokenId);
            const tags = Array.from(selectedBtns).map(btn => btn.dataset.tag);

            // Check if all selected tokens share at least ONE common tag
            const hand = Array.isArray(player.hand) ? player.hand : Object.values(player.hand || {});
            const thisRound = Array.isArray(player.thisRound) ? player.thisRound : Object.values(player.thisRound || {});
            const allTokens = [...hand, ...thisRound];
            const selectedTokenObjects = selectedTokenIds.map(id => allTokens.find(t => t.id === id));

            // Find common tags across all selected tokens
            const commonTags = selectedTokenObjects[0].tags.filter(tag =>
                selectedTokenObjects.every(token => token.tags.includes(tag))
            );

            // V5.1.2: Check for wildcard if no common tags
            let usedWildcard = false;
            if (commonTags.length === 0) {
                // Check if player has a wildcard active effect
                const wildcardEffect = player.activeEffects && player.activeEffects.find(e =>
                    e.effect === 'wildcard' && e.usesRemaining > 0
                );

                if (wildcardEffect) {
                    // Use wildcard to allow cash-in
                    usedWildcard = true;
                    wildcardEffect.usesRemaining--;

                    // Remove wildcard if no uses left
                    if (wildcardEffect.usesRemaining === 0) {
                        const effectIndex = player.activeEffects.indexOf(wildcardEffect);
                        player.activeEffects.splice(effectIndex, 1);
                        console.log(`🌈 ${player.name}'s wildcard exhausted and removed`);
                    }

                    showNotification(`🌈 Used ${wildcardEffect.name}! (${wildcardEffect.usesRemaining} uses left)`, 'success');
                    console.log(`🌈 ${player.name} used wildcard (${wildcardEffect.usesRemaining} uses remaining)`);
                } else {
                    showNotification('All selected tokens must share at least one common tag! (Or use a Wildcard card)', 'warning');
                    return;
                }
            }

            // Use the first common tag for scoring (or just use first token's first tag if wildcard was used)
            const selectedTag = commonTags.length > 0 ? commonTags[0] : selectedTokenObjects[0].tags[0];

            // Verify count (2, 3, or 4 only)
            const count = selectedTokenIds.length;
            if (count < 2 || count > 4) {
                showNotification('Must cash out 2, 3, or 4 tokens!', 'warning');
                return;
            }

            // Calculate base points
            let points = 0;
            if (count === 2) points = 2;
            else if (count === 3) points = 5;
            else if (count === 4) points = 8;

            // V5.0.2: Check for active multiplier effects
            let multiplier = 1;
            let multiplierCard = null;
            const multiplierEffect = player.activeEffects?.find(effect => effect.effect === 'multiplier' && effect.usesRemaining > 0);

            if (multiplierEffect) {
                multiplier = multiplierEffect.value;
                multiplierCard = multiplierEffect;
                points = points * multiplier;

                // Decrement uses
                multiplierEffect.usesRemaining--;

                // Remove effect if no uses remaining
                if (multiplierEffect.usesRemaining <= 0) {
                    const index = player.activeEffects.indexOf(multiplierEffect);
                    if (index > -1) {
                        player.activeEffects.splice(index, 1);
                    }
                }

                console.log(`✨ ${player.name} used ${multiplierCard.name}: ${points / multiplier} × ${multiplier} = ${points} pts`);
            }

            // Find and remove tokens from player's hand/thisRound
            // Convert to arrays if needed (Firebase sends objects)
            if (!Array.isArray(player.hand)) {
                player.hand = Object.values(player.hand || {});
            }
            if (!Array.isArray(player.thisRound)) {
                player.thisRound = Object.values(player.thisRound || {});
            }

            const tokensToRemove = [];
            selectedTokenIds.forEach(tokenId => {
                const fromHand = player.hand.findIndex(t => t.id === tokenId);
                if (fromHand !== -1) {
                    tokensToRemove.push(player.hand.splice(fromHand, 1)[0]);
                } else {
                    const fromThisRound = player.thisRound.findIndex(t => t.id === tokenId);
                    if (fromThisRound !== -1) {
                        tokensToRemove.push(player.thisRound.splice(fromThisRound, 1)[0]);
                    }
                }
            });

            // Add to retired tokens
            gameState.retiredTokens.push(...tokensToRemove);

            // Award points
            player.score += points;
            player.cashOuts++;

            // Create action metadata for opponent feedback
            const actionData = {
                type: 'cash_out',
                playerName: player.name,
                tokenCount: count,
                points: points,
                tag: selectedTag,
                tokensUsed: tokensToRemove.map(t => t.name),
                timestamp: Date.now()
            };

            // V5.0: Close cash out modal, then show bonus card pick modal
            closeCashOutModal();

            // V5.0: MANDATORY - Player must pick a bonus card after cash-in
            setTimeout(() => {
                showBonusCardPickModal();
            }, 300);

            // Show success animation on player panel
            const playerPanels = document.querySelectorAll('.player-info');
            if (playerPanels[gameState.currentPlayer]) {
                const panel = playerPanels[gameState.currentPlayer];
                panel.classList.add('animate-celebrate');
                setTimeout(() => panel.classList.remove('animate-celebrate'), 800);

                // Floating points animation
                showFloatingPoints(`+${points}`, panel);
            }

            // Show success notification
            const notificationMsg = multiplierCard
                ? `💰 ${player.name} cashed out ${count} tokens ${multiplierCard.name} for ${points} points! ✨`
                : `💰 ${player.name} cashed out ${count} tokens for ${points} points!`;
            showNotification(notificationMsg, 'success');

            // Sync to Firebase if online mode
            if (GameModeManager.isOnline()) {
                const playerIds = Object.keys(gameState.players);
                const currentPlayerId = playerIds[gameState.currentPlayer];

                // Update player data
                GameModeManager.updatePlayer(currentPlayerId, {
                    score: player.score,
                    cashOuts: player.cashOuts,
                    hand: player.hand,
                    thisRound: player.thisRound
                });

                // Update game state (without advancing turn yet)
                GameModeManager.updateGameState({
                    retiredTokens: gameState.retiredTokens,
                    passedPlayers: Array.from(gameState.passedPlayers), // Preserve passed players
                    lastAction: actionData
                });

                console.log('✅ Cash out synced to Firebase');
            } else {
                // LOCAL MODE: Update state directly
                gameState.retiredTokens = [...gameState.retiredTokens, ...tokensToRemove];
            }

            // V5.0: DO NOT advance turn here - the bonus card pick modal will handle it
            // The card pick is mandatory, so turn advancement happens after card selection
        }

        // ===== PASS =====
        function passRound() {
            // Turn validation for online mode
            if (GameModeManager.isOnline() && !GameModeManager.isMyTurn()) {
                showNotification("Wait for your turn!", 'warning');
                return;
            }

            // V4.97.15: Removed redundant locked-out check - advanceTurn() already prevents locked-out players from becoming currentPlayer
            // The pass button is also disabled by updateActionButtons() for locked-out players

            // Check if current player has already passed
            if (gameState.passedPlayers.has(gameState.currentPlayer)) {
                showNotification("You have already passed this round!", 'warning');
                return;
            }

            const player = getPlayerByIndex(gameState.currentPlayer);

            // Convert to arrays if Firebase sent objects
            if (!Array.isArray(player.hand)) {
                player.hand = Object.values(player.hand || {});
            }
            if (!Array.isArray(player.thisRound)) {
                player.thisRound = Object.values(player.thisRound || {});
            }

            // Move "this round" to hand
            player.hand.push(...player.thisRound);
            player.thisRound = [];

            // V4.97: Mark player as passed AND locked out
            gameState.passedPlayers.add(gameState.currentPlayer);
            gameState.lockedOutPlayers.add(gameState.currentPlayer);

            // V4.97: First to pass becomes first guesser next round
            const isFirstToPass = gameState.passedPlayers.size === 1;
            if (isFirstToPass) {
                gameState.firstGuesser = gameState.currentPlayer;
                console.log(`🎯 Player ${gameState.currentPlayer} is first to pass - will be first guesser next round`);
            }

            // V4.97.8: Show pass notification (broadcast to all players)
            const firstPassMsg = isFirstToPass ? ' Will go first next round!' : '';
            showNotification(`⏭️ ${player.name} passed. OUT for this round.${firstPassMsg}`, 'info', true);

            // Create action metadata for opponent feedback
            const actionData = {
                type: 'pass',
                playerName: player.name,
                isFirstToPass: isFirstToPass,
                timestamp: Date.now()
            };

            // V4.97.16: Sync lockedOutPlayers and passedPlayers to Firebase BEFORE calling advanceTurn
            // This is critical - other players need to see updated locked out status to know if round should end
            if (GameModeManager.isOnline()) {
                const playerIds = Object.keys(gameState.players);
                const currentPlayerId = playerIds[gameState.currentPlayer];

                // V4.97.16: Track timestamp to prevent Firebase listener from overwriting
                window.lastLockedOutPlayersUpdate = Date.now();

                // Update both player data AND game state in parallel
                GameModeManager.updatePlayer(currentPlayerId, {
                    hand: player.hand,
                    thisRound: player.thisRound
                });

                GameModeManager.updateGameState({
                    lockedOutPlayers: Array.from(gameState.lockedOutPlayers),
                    passedPlayers: Array.from(gameState.passedPlayers),
                    lockedOutPlayersTimestamp: window.lastLockedOutPlayersUpdate
                });

                console.log('🔍 DEBUG: Synced pass to Firebase - lockedOut:', Array.from(gameState.lockedOutPlayers), 'passed:', Array.from(gameState.passedPlayers));
            }

            // V4.97: Always call advanceTurn() - it will handle round end if all players locked out
            advanceTurn();
        }

        function endRound() {
            // V4.97.8: Close locked-out modal when round ends
            closeLockedOutModal();

            // V4.97: Award +1 bonus to last player to act (last standing)
            if (gameState.lastPlayerToAct !== null) {
                const lastPlayer = getPlayerByIndex(gameState.lastPlayerToAct);
                if (lastPlayer) {
                    lastPlayer.score += 1;
                    console.log(`🏆 Last standing bonus: +1 point to ${lastPlayer.name}`);
                    showNotification(`🏆 ${lastPlayer.name} gets +1 bonus for being last standing!`, 'success');

                    // Sync to Firebase if online mode
                    if (GameModeManager.isOnline()) {
                        const playerIds = Object.keys(gameState.players);
                        const lastPlayerId = playerIds[gameState.lastPlayerToAct];
                        GameModeManager.updatePlayer(lastPlayerId, {
                            score: lastPlayer.score
                        });
                    }
                }
            }

            // Move all "thisRound" tokens to player hands (make them safe)
            getPlayersArray().forEach(player => {
                // Convert to arrays if Firebase sent objects
                if (!Array.isArray(player.hand)) {
                    player.hand = Object.values(player.hand || {});
                }
                if (!Array.isArray(player.thisRound)) {
                    player.thisRound = Object.values(player.thisRound || {});
                }

                player.hand.push(...player.thisRound);
                player.thisRound = [];
            });

            // Return draft pool + center token to category pool (they stay in their category)
            if (gameState.selectedCategory) {
                const tokensToReturn = [...gameState.draftPool];
                if (gameState.centerToken) {
                    tokensToReturn.push(gameState.centerToken);
                }

                // These tokens stay in the category pool but are not "available" for the next draw
                // They stay in limbo until the game ends
                // For simplicity, we'll just leave them out of the pool (they're effectively retired for this game)
            }

            // Check if game is over
            if (gameState.round >= gameState.maxRounds) {
                // V4.97.23: Set flag IMMEDIATELY and sync to Firebase to prevent lockout overlay for all players
                window.gameEnding = true;
                gameState.gameEnding = true;

                // Sync gameEnding flag to Firebase so all players know
                if (GameModeManager.isOnline()) {
                    GameModeManager.updateGameState({
                        gameEnding: true
                    });
                }

                showNotification(`Round ${gameState.round} complete! Game Over!`, 'success');
                setTimeout(() => showGameEndScreen(), 1500);
                return;
            }

            showNotification(`Round ${gameState.round} ended! Starting next round...`, 'info');

            // Increment round
            gameState.round++;

            // Reset state for next round
            gameState.currentChallenge = null;
            gameState.selectedCategory = null;
            // V4.87: Keep previousCategory - it's used to track carryover between rounds
            // gameState.previousCategory stays for carryover tracking
            // V5.1.19: DON'T clear centerToken and draftPool here - they persist until new category selected
            // gameState.centerToken = null;
            // gameState.draftPool = [];
            gameState.passedPlayers = new Set(); // Clear passed players for new round
            gameState.lockedOutPlayers = new Set(); // V4.97: Clear locked-out players for new round
            gameState.lastPlayerToAct = null; // V4.97: Reset last player to act
            gameState.currentPlayer = gameState.firstGuesser; // V4.97: Reset current player to first guesser locally
            // V5.1.19: DON'T clear drawnChallengeCards - they should persist between rounds
            // startNewRound() will handle updating them (replace selected, keep others)

            // V4.75: Change phase back to 'challenge' after round ends
            // Reset the endRound flag so it can be called again next round
            window.endRoundCalled = false;

            // Sync state reset to Firebase if online mode
            // V4.89: Clear drawnChallengeCards to trigger startNewRound() via Firebase listener
            if (GameModeManager.isOnline()) {
                console.log('🔄 V4.89 endRound() syncing to Firebase:', {
                    round: gameState.round,
                    currentChallenge: null,
                    drawnChallengeCards: null
                });

                // V5.1.19: DON'T clear drawnChallengeCards - they should persist
                // V4.89: Clear current challenge only
                gameState.currentChallenge = null;

                // V4.97.21: Update timestamp FIRST, then clear locally to prevent listener race condition
                window.lastLockedOutPlayersUpdate = Date.now();

                // V4.97.19: Clear locked out players locally BEFORE syncing to Firebase
                gameState.lockedOutPlayers = new Set();
                gameState.passedPlayers = new Set();

                GameModeManager.updateGameState({
                    phase: 'challenge', // V4.75: Return to challenge phase
                    round: gameState.round,
                    currentChallenge: null,
                    selectedCategory: null,
                    previousCategory: gameState.previousCategory, // V4.87: Sync previousCategory for carryover tracking
                    centerToken: null,
                    draftPool: [],
                    passedPlayers: [], // Clear passed players in Firebase
                    lockedOutPlayers: [], // V4.97: Clear locked-out players in Firebase
                    lockedOutPlayersTimestamp: window.lastLockedOutPlayersUpdate, // V4.97.17: Update timestamp so clients accept the cleared array
                    lastPlayerToAct: null, // V4.97: Reset last player to act in Firebase
                    currentPlayer: gameState.firstGuesser, // Reset to first guesser for new round
                    allPassedFlag: false, // V4.84: Clear the all-passed flag
                    drawnChallengeCards: null // V4.89: Use null instead of [] to force Firebase update
                });

                // V4.81: In online mode, do NOT call startNewRound here
                // Let the first guesser handle it - the Firebase listener will trigger it
                console.log('✅ Round state synced to Firebase - first guesser will start new round');
            } else {
                // LOCAL MODE ONLY: Start next round directly
                startNewRound();
            }
        }

        // ===== GAME END =====
        function showGameEndScreen() {
            // V4.97.18: Clear lockout overlay for all players when game ends
            const overlay = document.getElementById('lockedOutOverlay');
            const gameScreen = document.getElementById('gameScreen');
            if (overlay) overlay.classList.remove('active');
            if (gameScreen) gameScreen.classList.remove('locked-out');
            console.log('🏁 Game ended - lockout overlay cleared for all players');

            // V5.0: Apply end-game bonus card scoring
            gameState.players.forEach(player => {
                let bonusPoints = 0;
                const bonusBreakdown = [];

                player.bonusCards.forEach(card => {
                    if (card.type === 'endgame') {
                        let cardBonus = 0;

                        switch(card.effect) {
                            case 'token_count':
                                // Points per token in hand
                                cardBonus = player.hand.length * card.value;
                                bonusBreakdown.push(`${card.name}: ${player.hand.length} tokens × ${card.value} = ${cardBonus} pts`);
                                break;

                            case 'cashout_count':
                                // Points per cash-in made
                                cardBonus = (player.cashOuts || 0) * card.value;
                                bonusBreakdown.push(`${card.name}: ${player.cashOuts || 0} cash-outs × ${card.value} = ${cardBonus} pts`);
                                break;

                            case 'card_count':
                                // Points per bonus card held
                                cardBonus = player.bonusCards.length * card.value;
                                bonusBreakdown.push(`${card.name}: ${player.bonusCards.length} cards × ${card.value} = ${cardBonus} pts`);
                                break;
                        }

                        bonusPoints += cardBonus;
                    }
                });

                if (bonusPoints > 0) {
                    player.score += bonusPoints;
                    console.log(`🎴 ${player.name} end-game bonus: +${bonusPoints} pts`);
                    bonusBreakdown.forEach(line => console.log(`  → ${line}`));
                }

                // Store bonus breakdown for display
                player.endGameBonus = bonusPoints;
                player.endGameBonusBreakdown = bonusBreakdown;
            });

            // Sort players by score (descending), then by tokens in hand, then by correct guesses
            const sortedPlayers = Object.values(gameState.players).sort((a, b) => {
                if (b.score !== a.score) return b.score - a.score;
                if (b.hand.length !== a.hand.length) return b.hand.length - a.hand.length;
                return b.correctGuesses - a.correctGuesses;
            });

            // Determine winner(s)
            const highestScore = sortedPlayers[0].score;
            const winners = sortedPlayers.filter(p => p.score === highestScore);

            // Winner announcement
            const winnerDiv = document.getElementById('winnerAnnouncement');
            if (winners.length === 1) {
                winnerDiv.innerHTML = `
                    <h1 style="font-size: 48px; margin-bottom: 10px;">🏆</h1>
                    <h2 style="font-size: 36px; margin-bottom: 10px;">${winners[0].name} Wins!</h2>
                    <p style="font-size: 24px; opacity: 0.9;">${winners[0].score} points</p>
                `;
            } else {
                winnerDiv.innerHTML = `
                    <h1 style="font-size: 48px; margin-bottom: 10px;">🏆</h1>
                    <h2 style="font-size: 36px; margin-bottom: 10px;">It's a Tie!</h2>
                    <p style="font-size: 24px; opacity: 0.9;">${winners.map(w => w.name).join(' & ')} - ${highestScore} points each</p>
                `;
            }

            // Final standings
            const standingsDiv = document.getElementById('finalStandings');
            standingsDiv.innerHTML = sortedPlayers.map((player, index) => {
                const medal = index === 0 ? '🥇' : index === 1 ? '🥈' : index === 2 ? '🥉' : '';
                return `
                    <div style="display: flex; justify-content: space-between; align-items: center; padding: 15px; border-bottom: 1px solid #eee;">
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <span style="font-size: 24px; min-width: 40px;">${medal}</span>
                            <div>
                                <div style="font-weight: bold; font-size: 18px; color: #764ba2;">${player.name}</div>
                                <div style="font-size: 12px; color: #666;">Tokens in hand: ${player.hand?.length || 0}</div>
                            </div>
                        </div>
                        <div style="font-size: 28px; font-weight: bold; color: #764ba2;">${player.score} pts</div>
                    </div>
                `;
            }).join('');

            // Game stats
            const statsDiv = document.getElementById('gameStats');
            statsDiv.innerHTML = sortedPlayers.map(player => `
                <div style="margin-bottom: 20px; padding-bottom: 20px; border-bottom: 1px solid #eee;">
                    <h3 style="color: #764ba2; margin-bottom: 10px;">${player.name}</h3>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; font-size: 14px;">
                        <div>✅ Correct Guesses: <strong>${player.correctGuesses || 0}</strong></div>
                        <div>💰 Cash Outs: <strong>${player.cashOuts || 0}</strong></div>
                        <div>🃏 Tokens in Hand: <strong>${player.hand?.length || 0}</strong></div>
                        <div>🎴 Bonus Cards: <strong>${player.bonusCards?.length || 0}</strong></div>
                        ${player.endGameBonus > 0 ? `<div style="grid-column: span 2; color: #f5576c; font-weight: bold;">🎁 End-Game Bonus: +${player.endGameBonus} pts</div>` : ''}
                        <div style="grid-column: span 2; font-size: 16px; margin-top: 5px;">🎯 Final Score: <strong>${player.score || 0} pts</strong></div>
                    </div>
                    ${player.bonusCards?.length > 0 ? `
                        <div style="margin-top: 15px; padding: 10px; background: #f8f8f8; border-radius: 8px;">
                            <div style="font-weight: bold; color: #764ba2; margin-bottom: 8px;">🎴 Bonus Cards Collected:</div>
                            ${player.bonusCards.map(card => `
                                <div style="font-size: 12px; margin-bottom: 4px; padding: 5px; background: white; border-radius: 4px;">
                                    ${card.name} <span style="color: #666; font-size: 11px;">(${card.type})</span>
                                </div>
                            `).join('')}
                        </div>
                    ` : ''}
                    ${player.endGameBonusBreakdown?.length > 0 ? `
                        <div style="margin-top: 10px; padding: 10px; background: #fff3cd; border-radius: 8px;">
                            <div style="font-weight: bold; color: #856404; margin-bottom: 5px;">🎁 Bonus Breakdown:</div>
                            ${player.endGameBonusBreakdown.map(line => `
                                <div style="font-size: 11px; color: #856404; margin-bottom: 2px;">• ${line}</div>
                            `).join('')}
                        </div>
                    ` : ''}
                </div>
            `).join('');

            // Show screen
            showScreen('gameEndScreen');
        }

        // ===== UTILITIES =====
        function showScreen(screenId) {
            document.querySelectorAll('.screen').forEach(screen => {
                screen.classList.remove('active');
            });
            document.getElementById(screenId).classList.add('active');
        }

        function showNotification(message, type = 'info', broadcastToAll = false) {
            // Display notification locally
            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.textContent = message;
            document.body.appendChild(notification);

            setTimeout(() => {
                notification.remove();
            }, 3000);

            // V4.97.8: Broadcast to all players in online mode
            if (broadcastToAll && GameModeManager.isOnline()) {
                GameModeManager.updateGameState({
                    lastNotification: {
                        message: message,
                        type: type,
                        timestamp: Date.now()
                    }
                });
            }
        }

        function showFloatingPoints(text, parentElement) {
            const floater = document.createElement('div');
            floater.className = 'points-float';
            floater.textContent = text;

            const rect = parentElement.getBoundingClientRect();
            floater.style.left = rect.left + rect.width / 2 - 20 + 'px';
            floater.style.top = rect.top + rect.height / 2 + 'px';

            document.body.appendChild(floater);

            setTimeout(() => floater.remove(), 1000);
        }

        function showOpponentAction(message, type = 'info', duration = 4000) {
            // Create persistent banner at top of screen
            let banner = document.getElementById('opponentActionBanner');
            if (!banner) {
                banner = document.createElement('div');
                banner.id = 'opponentActionBanner';
                banner.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    right: 0;
                    padding: 15px;
                    text-align: center;
                    font-weight: bold;
                    z-index: 10000;
                    animation: slideDown 0.3s ease-out;
                `;
                document.body.appendChild(banner);
            }

            // Set color based on type
            const colors = {
                success_green: 'background: linear-gradient(135deg, #34d399 0%, #10b981 100%); color: white;',  // Green for cash out
                success_blue: 'background: linear-gradient(135deg, #1e40af 0%, #1e3a8a 100%); color: white;',   // Darker blue for correct guesses
                error: 'background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%); color: white;',          // Red for wrong guesses
                warning: 'background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%); color: white;',        // Yellow for pass
                info: 'background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;'            // Purple fallback
            };

            banner.style.cssText += colors[type] || colors.info;
            banner.textContent = message;

            // Clear any existing timeout
            if (banner.hideTimeout) clearTimeout(banner.hideTimeout);

            // Auto-hide after specified duration
            banner.hideTimeout = setTimeout(() => {
                banner.style.animation = 'slideUp 0.3s ease-in';
                setTimeout(() => banner.remove(), 300);
            }, duration);
        }

        function updateTurnIndicator() {
            // Create or update a persistent turn indicator in the header
            let indicator = document.getElementById('turnIndicator');
            if (!indicator) {
                indicator = document.createElement('div');
                indicator.id = 'turnIndicator';
                indicator.style.cssText = `
                    position: fixed;
                    top: 60px;
                    right: 20px;
                    padding: 10px 20px;
                    border-radius: 25px;
                    font-weight: bold;
                    font-size: 14px;
                    z-index: 9999;
                    transition: all 0.3s ease;
                `;
                document.body.appendChild(indicator);
            }

            if (GameModeManager.isOnline()) {
                // During challenge selection: check if I'm the first guesser
                // During guess phase: check if I'm the current player
                let isMyAction = false;

                // Check if modal is currently showing (challenge selection active)
                const modal = document.getElementById('categoryModal');
                const isModalActive = modal && modal.classList.contains('active');

                // CRITICAL: If modal is active, ALWAYS check first guesser (not currentPlayer)
                if (isModalActive) {
                    // Challenge selection phase: only first guesser can select
                    const playerIds = window.playerIds || Object.keys(gameState.players || {});
                    const firstGuesserId = playerIds[gameState.firstGuesser];
                    isMyAction = (firstGuesserId === window.currentUserId);
                    console.log(`🎯 Turn indicator (MODAL ACTIVE): modal=${isModalActive}, firstGuesser=${gameState.firstGuesser}, firstGuesserId=${firstGuesserId}, currentUserId=${window.currentUserId}, isMyAction=${isMyAction}`);
                } else if (!gameState.currentChallenge && gameState.challengeMode === 'cards') {
                    // Challenge selection phase but modal not shown yet
                    const playerIds = window.playerIds || Object.keys(gameState.players || {});
                    const firstGuesserId = playerIds[gameState.firstGuesser];
                    isMyAction = (firstGuesserId === window.currentUserId);
                    console.log(`🎯 Turn indicator (BEFORE MODAL): firstGuesser=${gameState.firstGuesser}, firstGuesserId=${firstGuesserId}, currentUserId=${window.currentUserId}, isMyAction=${isMyAction}`);
                } else {
                    // Guess phase or other phases: check current player
                    isMyAction = GameModeManager.isMyTurn();
                    console.log(`🎯 Turn indicator (GUESS PHASE): currentPlayer=${gameState.currentPlayer}, isMyTurn=${isMyAction}`);
                }

                console.log(`🎯 Turn indicator - isMyAction=${isMyAction}, about to update UI`);

                if (isMyAction) {
                    indicator.textContent = '🎯 YOUR TURN';
                    indicator.style.background = 'linear-gradient(135deg, #34d399 0%, #10b981 100%)';
                    indicator.style.color = 'white';
                    indicator.style.boxShadow = '0 4px 15px rgba(16, 185, 129, 0.4)';
                    indicator.style.display = 'block';
                    console.log(`✅ Turn indicator set to YOUR TURN (green)`);
                } else {
                    indicator.textContent = '⏳ Waiting...';
                    indicator.style.background = 'linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%)';
                    indicator.style.color = 'white';
                    indicator.style.boxShadow = '0 4px 15px rgba(245, 158, 11, 0.4)';
                    indicator.style.display = 'block';
                    console.log(`⏳ Turn indicator set to Waiting (yellow)`);
                }
            } else {
                indicator.style.display = 'none';
            }
        }

        function highlightToken(tokenElementId) {
            const element = document.getElementById(tokenElementId);
            if (element) {
                element.classList.add('opponent-action-highlight');
                setTimeout(() => {
                    element.classList.remove('opponent-action-highlight');
                }, 2000);
            }
        }

        function formatNumber(num) {
            if (num === undefined || num === null) return 'N/A';
            if (num >= 1000000000) {
                return (num / 1000000000).toFixed(2) + 'B';
            } else if (num >= 1000000) {
                return (num / 1000000).toFixed(1) + 'M';
            }
            return num.toLocaleString();
        }

        function toggleDataVisibility() {
            const isHidden = document.body.classList.toggle('hide-data');
            const btn = document.getElementById('toggleDataBtn');

            if (isHidden) {
                btn.textContent = '👁️ Show Data';
                showNotification('Data values hidden - play mode activated!', 'info');
            } else {
                btn.textContent = '👁️ Hide Data';
                showNotification('Data values visible', 'info');
            }
        }

        // ===== QA TEST RUNNER =====
        async function runAutomatedQA() {
            console.log('🚀 Starting automated QA tests...\n');

            // Run tests
            const results = await runQATests();

            // Show alert with summary
            const emoji = results.failed === 0 ? '✅' : '❌';
            alert(`${emoji} QA Test Results\n\n` +
                  `Total: ${results.total}\n` +
                  `Passed: ${results.passed}\n` +
                  `Failed: ${results.failed}\n` +
                  `Success Rate: ${results.successRate.toFixed(1)}%\n\n` +
                  `Check console for detailed results.`);
        }

        async function runFullGameTestUI() {
            console.log('🎮 Starting Full Game Test...\n');
            console.log('Watch the console for detailed play-by-play!\n');

            // Check if test is available
            if (typeof runFullGameTest !== 'function') {
                alert('❌ Error: Full game test not loaded.\n\nPlease refresh the page and try again.');
                console.error('runFullGameTest function not found');
                return;
            }

            // Show starting notification
            const startTime = Date.now();
            console.log('════════════════════════════════════════');
            console.log('🎮 FULL GAME TEST - 3 Players, 5 Rounds');
            console.log('════════════════════════════════════════\n');

            try {
                // Run the test
                const result = await runFullGameTest();

                // Calculate duration
                const duration = ((Date.now() - startTime) / 1000).toFixed(2);

                // Show completion alert
                const emoji = result.success ? '✅' : '⚠️';
                const status = result.success ? 'Success!' : 'Completed with warnings';

                alert(`${emoji} Full Game Test Complete!\n\n` +
                      `Status: ${status}\n` +
                      `Duration: ${duration}s\n` +
                      `Actions: ${result.log.length}\n` +
                      `Errors: ${result.errors.length}\n\n` +
                      `Check console for detailed game log.`);

                console.log('\n════════════════════════════════════════');
                console.log(`✅ Test completed in ${duration}s`);
                console.log('════════════════════════════════════════\n');

            } catch (error) {
                console.error('❌ Test failed:', error);
                alert(`❌ Test Error\n\n${error.message}\n\nCheck console for details.`);
            }
        }

        // ===== EVENT LISTENERS =====
        document.getElementById('numPlayers').addEventListener('change', updatePlayerInputs);

        // ===== INITIALIZE ON LOAD =====
        window.addEventListener('DOMContentLoaded', initializeGame);
    </script>
</body>
</html>
